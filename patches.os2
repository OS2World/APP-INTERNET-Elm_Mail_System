Only in new: README.OS2
Only in new: README.PGP
Only in new: README.TCP
Only in new: elm-tcp.rc
Only in new: config.h
Only in new: patches.os2
Only in new/utils: sndmail.c
Only in new: os2/*
Only in new: crypt/*
diff -cbr orig/filter/actions.c new/filter/actions.c
*** orig/filter/actions.c	Sat Oct 16 18:43:32 1993
--- new/filter/actions.c	Sun Sep 26 15:13:48 1993
***************
*** 68,74 ****
  		   username, address);
  
  	if (! show_only) {
! 	  sprintf(tempfile, "%s.%d", filter_temp, getpid());
  
  	  if ((tempfd = fopen(tempfile, "r")) == NULL) {
  	    if (outfd != NULL)
--- 68,74 ----
  		   username, address);
  
  	if (! show_only) {
! 	  sprintf(tempfile, "%s%d.fil", tempdir, getpid());
  
  	  if ((tempfd = fopen(tempfile, "r")) == NULL) {
  	    if (outfd != NULL)
***************
*** 84,113 ****
  	      if (contains(from, username)) {
  		if (outfd != NULL)
  	          fprintf(outfd,
! 	"filter (%s): Filter loop detected!  Message left in file %s.%d\n", 
! 			username, filter_temp, getpid());
  	        if (outfd != NULL) fclose(outfd);
  	        exit(0);
  	      }
  	    }
  
  	    if (strcmp(sendmail, mailer) == 0)
! 	      sprintf(buffer, "%s %s %s", sendmail, smflags, address);
  	    else
! 	      sprintf(buffer, "%s %s", mailer, address);
  
  	    if ((pipefd = popen(buffer, "w")) == NULL) {
  	      if (outfd != NULL)
  	        fprintf(outfd, "filter (%s): popen %s failed!\n", username, buffer);
! 	      sprintf(buffer, "((%s %s %s ; %s %s) & ) < %s &",
! 		      sendmail , smflags, address, remove_cmd, tempfile, tempfile);
  	      system(buffer);
  	      return;
  	    }
  
  	    fprintf(pipefd, "Subject: \"%s\"\n", subject);
! 	    fprintf(pipefd, "From: The Filter of %s@%s <%s>\n", 
! 		    username, hostname, username);
  	    fprintf(pipefd, "To: %s\n", address);
  	    fprintf(pipefd, "X-Filtered-By: filter, version %s\n\n", VERSION);
  
--- 84,113 ----
  	      if (contains(from, username)) {
  		if (outfd != NULL)
  	          fprintf(outfd,
! 	"filter (%s): Filter loop detected!  Message left in file %s\n",
! 			username, tempfile);
  	        if (outfd != NULL) fclose(outfd);
  	        exit(0);
  	      }
  	    }
  
  	    if (strcmp(sendmail, mailer) == 0)
! 	      sprintf(buffer, "%s -f %s@%s %s", sendmail, username, hostfromname, address);
  	    else
! 	      sprintf(buffer, "%s -t", mailer);
  
  	    if ((pipefd = popen(buffer, "w")) == NULL) {
  	      if (outfd != NULL)
  	        fprintf(outfd, "filter (%s): popen %s failed!\n", username, buffer);
! 	      sprintf(buffer, "%s -t <%s", mailer, tempfile);
  	      system(buffer);
+               unlink(tempfile);
  	      return;
  	    }
  
  	    fprintf(pipefd, "Subject: \"%s\"\n", subject);
! 	    fprintf(pipefd, "From: %s@%s (The Filter of %s)\n",
! 		    username, hostfromname, username);
  	    fprintf(pipefd, "To: %s\n", address);
  	    fprintf(pipefd, "X-Filtered-By: filter, version %s\n\n", VERSION);
  
***************
*** 120,126 ****
  	        fprintf(pipefd," %s", buffer);
  
  	    fprintf(pipefd, "\n-- End of filtered message --\n");
! 	    fclose(pipefd);
  	    fclose(tempfd);
  
  	    return;		/* YEAH!  Wot a slick program, eh? */
--- 120,126 ----
  	        fprintf(pipefd," %s", buffer);
  
  	    fprintf(pipefd, "\n-- End of filtered message --\n");
! 	    pclose(pipefd);
  	    fclose(tempfd);
  
  	    return;		/* YEAH!  Wot a slick program, eh? */
***************
*** 146,151 ****
--- 146,155 ----
  	  else if ((mailfd = emergency_local_delivery()) == NULL)
  	    exit(1);
  
+ #ifdef MMDF
+ 	  fputs(MSG_SEPERATOR, mailfd);
+ #endif
+ 
  	  while (fgets(buffer, sizeof(buffer), tempfd) != NULL) {
  	    line_count++;
  	    if (the_same(buffer, "From ") && line_count > 1)
***************
*** 154,160 ****
  	      fputs(buffer, mailfd);
  	  }
  
! 	  fputs("\n", mailfd);
  
  	  fclose(mailfd);
  	  unlock();		/* blamo or not?  Let it decide! */
--- 158,164 ----
  	      fputs(buffer, mailfd);
  	  }
  
! 	  fputs("\n\n", mailfd);
  
  	  fclose(mailfd);
  	  unlock();		/* blamo or not?  Let it decide! */
***************
*** 177,183 ****
  		  username, foldername);
  
  	if (!show_only) {
! 	  sprintf(filename, "%s.%d", filter_temp, getpid());
  
  	  if ((fdunit = open(foldername, O_APPEND | O_WRONLY | O_CREAT, 0600)) < 0) {
  	    if (outfd != NULL)
--- 181,187 ----
  		  username, foldername);
  
  	if (!show_only) {
! 	  sprintf(filename, "%s%d.fil", tempdir, getpid());
  
  	  if ((fdunit = open(foldername, O_APPEND | O_WRONLY | O_CREAT, 0600)) < 0) {
  	    if (outfd != NULL)
***************
*** 196,201 ****
--- 200,209 ----
  	     return(1);
  	  }
  
+ #ifdef MMDF
+ 	  fputs(MSG_SEPERATOR, fd);
+ #endif
+ 
  	  while (fgets(buffer, sizeof(buffer), tempfd) != NULL)
  	    fputs(buffer, fd);
  
***************
*** 226,232 ****
  	  fprintf(outfd, "filter (%s): Executing %s\n", username, command);
  
  	if (! show_only) {
! 	  sprintf(buffer, "%s %s.%d | %s", cat, filter_temp, getpid(), command);
  	  system(buffer);
  	}
  }
--- 234,240 ----
  	  fprintf(outfd, "filter (%s): Executing %s\n", username, command);
  
  	if (! show_only) {
! 	  sprintf(buffer, "%s <%s%d.fil", command, tempdir, getpid());
  	  system(buffer);
  	}
  }
diff -cbr orig/filter/filter.c new/filter/filter.c
*** orig/filter/filter.c	Sat Oct 16 18:43:34 1993
--- new/filter/filter.c	Fri Dec 31 11:48:22 1993
***************
*** 59,64 ****
--- 59,66 ----
  #define  MAIN_ROUTINE			/* for the filter.h file, of course! */
  #include "filter.h"
  
+ #undef fflush
+ 
  main(argc, argv)
  int argc;
  char *argv[];
***************
*** 76,99 ****
  	     summary   = FALSE,			/* a summary is requested?  */
  	     c;					/* var for getopt routine   */
  
! 	/* first off, let's get the info from /etc/passwd */
! 
! 	if ((passwd_entry = getpwuid(getuid())) == NULL)
! 	  leave("Cannot get password entry for this uid!");
  
- 	strcpy(home, passwd_entry->pw_dir);
- 	strcpy(username, passwd_entry->pw_name);
  	outfname[0] = to[0] = '\0';	/* nothing read in yet, right? */
  
  #ifdef HOSTCOMPILED
  	strncpy(hostname, HOSTNAME, sizeof(hostname));
  #else
  	gethostname(hostname, sizeof(hostname));
  #endif
  
  	/* now parse the starting arguments... */
  
! 	while ((c = getopt(argc, argv, "clno:rSsv")) != EOF) {
  	  switch (c) {
  	    case 'c' : clear_logs = TRUE;			break;
  	    case 'l' : log_actions_only = TRUE;			break;
--- 78,102 ----
  	     summary   = FALSE,			/* a summary is requested?  */
  	     c;					/* var for getopt routine   */
  
!         initpaths();
  
  	outfname[0] = to[0] = '\0';	/* nothing read in yet, right? */
  
  #ifdef HOSTCOMPILED
  	strncpy(hostname, HOSTNAME, sizeof(hostname));
  #else
  	gethostname(hostname, sizeof(hostname));
+ #endif
+ 
+ #ifdef OS2
+ 	getfromdomain(hostfromname, sizeof(hostfromname));
+ #else
+ 	strcpy(hostfromname, hostname);
  #endif
  
  	/* now parse the starting arguments... */
  
! 	while ((c = getopt(argc, argv, "clno:rSsu:v")) != EOF) {
  	  switch (c) {
  	    case 'c' : clear_logs = TRUE;			break;
  	    case 'l' : log_actions_only = TRUE;			break;
***************
*** 104,118 ****
  	    case 'S' : long_summary = TRUE;			break;
  
  	    case 'n' : show_only = TRUE;			break;
  	    case 'v' : verbose = TRUE;				break;
! 	    case '?' : fprintf(stderr, 
! 		       "Usage: | filter [-nrv]\n   or: filter [-c] -[s|S]\n");
!           	       exit(1);
  	  }
  	}
  
! 	if (c < 0) {
! 	}
  
  	/* let's open our outfd logfile as needed... */
  
--- 109,130 ----
  	    case 'S' : long_summary = TRUE;			break;
  
  	    case 'n' : show_only = TRUE;			break;
+ 	    case 'u' : strcpy(username, optarg);		break;
  	    case 'v' : verbose = TRUE;				break;
! 	    case '?' : usage(argv[0]);
  	  }
  	}
  
! 	/* first off, let's get the info from /etc/passwd */
! 	passwd_entry = username[0] ? getpwnam(username) : getpwuid(getuid());
! 	if (passwd_entry == NULL)
! 	  leave("Cannot get password entry for this uid!");
! 
! 	strcpy(home, passwd_entry->pw_dir);
! 	strcpy(username, passwd_entry->pw_name);
! 
! 	if (isatty(0) && !summary && !long_summary && !printing_rules)
!           usage(argv[0]);
  
  	/* let's open our outfd logfile as needed... */
  
***************
*** 146,152 ****
  
  	/* next, create the tempfile and save the incoming message */
  
! 	sprintf(filename, "%s.%d", filter_temp, getpid());
  
  	if ((fd = fopen(filename,"w")) == NULL)
  	  leave("Cannot open temporary file!");
--- 158,164 ----
  
  	/* next, create the tempfile and save the incoming message */
  
! 	sprintf(filename, "%s%d.fil", tempdir, getpid());
  
  	if ((fd = fopen(filename,"w")) == NULL)
  	  leave("Cannot open temporary file!");
***************
*** 229,234 ****
--- 241,263 ----
  	(void) unlink(filename);	/* remove the temp file, please! */
  	if (outfd != NULL) fclose(outfd);
  	exit(0);
+ }
+ 
+ 
+ usage(name)
+ char *name;
+ {
+   printf("\nUsage: filter [-nrv] [-o output] [-u user]"
+          "\n   or: filter [-s|-S] [-c] [-o output] [-u user]\n"
+          "\nWhere: -n   not really, only output what would happen"
+          "\n       -v   be verbose for each message filtered"
+          "\n       -r   list rules currently beeing used"
+          "\n       -s   list summary of message filtered log"
+          "\n       -S   list more verbose summary that -s"
+          "\n       -c   clear log files after summarizing with -s or -S"
+          "\n       -o output    redirect log message to 'output'"
+ 	 "\n       -u user      work under user ID 'user'\n");
+   exit(1);
  }
  
  save_from(buffer)
diff -cbr orig/filter/lock.c new/filter/lock.c
*** orig/filter/lock.c	Sat Oct 16 18:43:34 1993
--- new/filter/lock.c	Sun Mar 22 15:09:16 1992
***************
*** 59,66 ****
  static	char flock_name[SLEN];
  #endif
  
- extern  int  errno;
- 
  char *
  mk_lockname(home, user)
  char *home, *user;
--- 59,64 ----
***************
*** 74,80 ****
  	sprintf(lockfile, "/tmp/%.10s.mlk", user);
  #else
  	/* lock is [file_to_lock].lock */
! 	sprintf(lockfile, "%s%s.lock", home, user);
  #endif
  	return(lockfile);
  }
--- 72,78 ----
  	sprintf(lockfile, "/tmp/%.10s.mlk", user);
  #else
  	/* lock is [file_to_lock].lock */
! 	sprintf(lockfile, "%s%s.lck", home, user);
  #endif
  	return(lockfile);
  }
***************
*** 112,118 ****
          }
  #endif
  
! 	while ((ret = open(lockfile, O_WRONLY | O_CREAT | O_EXCL, 0444)) < 0 
  	       && attempts++ < 10) {
  	  sleep(3);	/* wait three seconds each pass, okay?? */
  	}
--- 110,116 ----
          }
  #endif
  
! 	while ((ret = open(lockfile, O_WRONLY | O_CREAT | O_EXCL, 0666)) < 0
  	       && attempts++ < 10) {
  	  sleep(3);	/* wait three seconds each pass, okay?? */
  	}
***************
*** 128,134 ****
  #endif					/* } !LOCK_FLOCK_ONLY	*/
  #ifdef	LOCK_BY_FLOCK			/* { LOCK_BY_FLOCK	*/
  	(void)sprintf(flock_name,"%s%s",mailhome,username);
! 	flock_fd = open(flock_name, O_RDONLY | O_CREAT, 0600);
  	if ( flock_fd >= 0 )
  	  for (attempts = 0; attempts < 10; attempts++) {
  	    if ( (ret = flock(flock_fd,LOCK_NB|LOCK_EX)) != -1 )
--- 126,132 ----
  #endif					/* } !LOCK_FLOCK_ONLY	*/
  #ifdef	LOCK_BY_FLOCK			/* { LOCK_BY_FLOCK	*/
  	(void)sprintf(flock_name,"%s%s",mailhome,username);
! 	flock_fd = open(flock_name, O_RDONLY | O_CREAT, 0666);
  	if ( flock_fd >= 0 )
  	  for (attempts = 0; attempts < 10; attempts++) {
  	    if ( (ret = flock(flock_fd,LOCK_NB|LOCK_EX)) != -1 )
diff -cbr orig/filter/Makefile new/filter/Makefile
*** orig/filter/Makefile	Sat Oct 16 18:43:34 1993
--- new/filter/Makefile	Fri Apr 22 21:19:20 1994
***************
*** 2,19 ****
  #  Makefile for the Elm system filter program for OS/2
  #
  
! gcc:
  	$(MAKE) all CC="gcc -O -Zomf -Zmtd" O=".obj" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm32.def"
  
! gccdebug:
  	$(MAKE) all CC="gcc -g" O=".o" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm32.def"
! 
! msc:
! 	$(MAKE) all CC="cl -nologo -AL -Gs -Ocegt" O=".obj" \
! 	CFLAGS="-W1 -Zep1 -Gt16 -D__STDC__ -G2 -J" \
! 	LFLAGS="-Lp" LIBS="..\os2\elm16.def -link /noe /packc /packd"
  
  # Variables
  
--- 2,14 ----
  #  Makefile for the Elm system filter program for OS/2
  #
  
! release:
  	$(MAKE) all CC="gcc -O -Zomf -Zmtd" O=".obj" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm.def"
  
! debug:
  	$(MAKE) all CC="gcc -g" O=".o" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm.def"
  
  # Variables
  
***************
*** 25,31 ****
  
  # Lists
  
! OS2_OBJ		= getopt$O os2util$O
  FILTER_OBJ	= actions$O buffer$O filter$O lock$O parse$O \
  		  rules$O summarize$O utils$O opt_utils$O $(OS2_OBJ)
  
--- 20,26 ----
  
  # Lists
  
! OS2_OBJ		= getopt$O os2util$O movemail$O
  FILTER_OBJ	= actions$O buffer$O filter$O lock$O parse$O \
  		  rules$O summarize$O utils$O opt_utils$O $(OS2_OBJ)
  
***************
*** 78,80 ****
--- 73,77 ----
  		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/getopt.c
  os2util$O:	$(OS2DIR)/os2util.c
  		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/os2util.c
+ movemail$O:	$(OS2DIR)/movemail.c
+ 		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/movemail.c
diff -cbr orig/filter/rules.c new/filter/rules.c
*** orig/filter/rules.c	Sat Oct 16 18:43:34 1993
--- new/filter/rules.c	Sun Oct 04 13:37:56 1992
***************
*** 120,126 ****
  
  #ifndef	_POSIX_SOURCE
  	struct tm *localtime();
! 	long    time();
  #endif
  	struct tm *timerec;
  	long	thetime;
--- 120,126 ----
  
  #ifndef	_POSIX_SOURCE
  	struct tm *localtime();
! 	time_t time();
  #endif
  	struct tm *timerec;
  	long	thetime;
diff -cbr orig/filter/utils.c new/filter/utils.c
*** orig/filter/utils.c	Sat Oct 16 18:43:36 1993
--- new/filter/utils.c	Sun Mar 22 14:27:26 1992
***************
*** 40,45 ****
--- 40,47 ----
  #include "defs.h"
  #include "filter.h"
  
+ #undef fflush
+ 
  leave(reason)
  char *reason;
  {
diff -cbr orig/src/hdrconfg.c new/src/hdrconfg.c
*** orig/src/hdrconfg.c	Fri Jan 18 10:01:52 1991
--- new/src/hdrconfg.c	Mon Oct  7 22:03:12 1996
***************
*** 103,108 ****
--- 103,109 ----
  {
  	/** Edit headers.  **/
  	int c, displayed_error = NO;
+ 	char expanded_address[VERY_LONG_STRING];
  
  	/*  Expand address-type headers for main part of display */
  	/*  (Unexpanded ones are used on the 'edit-line') */
***************
*** 120,126 ****
  	    displayed_error = NO;
  	  else
  	    CleartoEOS();
! 	  c = getchar();
  	  if (isupper(c))
  	    c = tolower(c);
  	  clear_error();
--- 120,127 ----
  	    displayed_error = NO;
  	  else
  	    CleartoEOS();
! 	  c = ReadCh();
! 	  /* c = getchar(); */
  	  if (isupper(c))
  	    c = tolower(c);
  	  clear_error();
***************
*** 171,176 ****
--- 172,179 ----
  	    		if(optionally_enter(reply_to,
  			      INPUT_LINE, 10, FALSE, FALSE) == -1)
  			  return(0);
+ 			(void) build_address(strip_commas(reply_to), expanded_address);
+ 			strcpy(reply_to, expanded_address);
  			put_replyto();
  			break;
  
diff -cbr orig/hdrs/defs.h new/hdrs/defs.h
*** orig/hdrs/defs.h	Sat Oct 16 18:43:36 1993
--- new/hdrs/defs.h	Wed Sep 08 23:26:12 1993
***************
*** 36,41 ****
--- 36,45 ----
  #include "../config.h"
  #include "sysdefs.h"	/* system/configurable defines */
  
+ #ifdef OS2
+ #include "../os2/os2elm.h"
+ #endif
+ 
  
  # define VERSION 		"2.3"		/* Version number... */
  # define VERS_DATE	"May 1, 1990"		/* for elm -v option */
***************
*** 113,125 ****
  #define DONT_SAVE	"[no save]"
  #define DONT_SAVE2	"[nosave]"
  
- #define alias_file	".aliases"
- #define group_file	".groups"
- #define system_file	".systems"
- 
- #define default_folders		"Mail"
- #define default_recvdmail	"=received"
- #define default_sentmail	"=sent"
  
  /** some defines for the 'userlevel' variable... **/
  
--- 117,122 ----
***************
*** 169,176 ****
  #define DECEMBER	11
  
  #define equal(s,w)	(strcmp(s,w) == 0)
! #define min(a,b)	a < b? a : b
! #define ctrl(c)	        c - 'A' + 1	/* control character mapping */
  #define plural(n)	n == 1 ? "" : "s"
  #define lastch(s)	s[strlen(s)-1]
  
--- 166,173 ----
  #define DECEMBER	11
  
  #define equal(s,w)	(strcmp(s,w) == 0)
! #define min(a,b)	(a < b? a : b)
! #define ctrl(c)	        (c == '?' ? 127 : c - 'A' + 1)	/* control character mapping */
  #define plural(n)	n == 1 ? "" : "s"
  #define lastch(s)	s[strlen(s)-1]
  
***************
*** 258,263 ****
--- 255,261 ----
  
  #define PMALLOC_THRESHOLD	256	/* if greater, then just use malloc */
  #define PMALLOC_BUFFER_SIZE    2048	/* internal [memory] buffer size... */
+ 
  
  /** the following macro is as suggested by Larry McVoy.  Thanks! **/
  
diff -cbr orig/hdrs/elm.h new/hdrs/elm.h
*** orig/hdrs/elm.h	Sat Oct 16 18:43:36 1993
--- new/hdrs/elm.h	Tue Sep 28 23:25:40 1993
***************
*** 34,40 ****
  #include "../hdrs/curses.h"
  #include "../hdrs/defs.h"
  
! #ifdef	BSD
  #include <setjmp.h>
  #endif
  
--- 34,40 ----
  #include "../hdrs/curses.h"
  #include "../hdrs/defs.h"
  
! #if defined(BSD) || defined(OS2)
  #include <setjmp.h>
  #endif
  
***************
*** 57,62 ****
--- 57,64 ----
  int headers_per_page;		/* number of headers/page  */
  int original_umask = 0;		/* original umask, for restore before subshell */
  int sendmail_verbose = 0;       /* Extended mail debugging */
+ int no_save = 0;		/* Do not save outgoing mail */
+ int mmdf_strict = 0;		/* Strict MMDF mailbox scanning */
  char cur_folder[SLEN];          /* name of current folder */
  char cur_tempfolder[SLEN];      /* name of temp folder open for a mailbox */
  char defaultfile[SLEN];         /* name of default folder */
***************
*** 64,69 ****
--- 66,72 ----
  char hostname[SLEN];            /* name of machine we're on*/
  char hostdomain[SLEN];          /* name of domain we're in */
  char hostfullname[SLEN];        /* name of FQDN we're in */
+ char hostfromname[SLEN];        /* name of FQDN we pretend to be in */
  char username[SLEN];            /* return address name!    */
  char full_username[SLEN];       /* Full username - gecos   */
  char home[SLEN];                /* home directory of user  */
***************
*** 177,183 ****
  int userid;			/* uid for current user	      */
  int groupid;			/* groupid for current user   */
  
! #ifdef	BSD
  jmp_buf GetPromptBuf;		/* setjmp buffer */
  int InGetPrompt;		/* set if in GetPrompt() in read() */
  #endif
--- 180,186 ----
  int userid;			/* uid for current user	      */
  int groupid;			/* groupid for current user   */
  
! #if defined(BSD) || defined(OS2)
  jmp_buf GetPromptBuf;		/* setjmp buffer */
  int InGetPrompt;		/* set if in GetPrompt() in read() */
  #endif
diff -cbr orig/hdrs/filter.h new/hdrs/filter.h
*** orig/hdrs/filter.h	Sat Oct 16 18:43:36 1993
--- new/hdrs/filter.h	Sun Sep 26 15:16:24 1993
***************
*** 42,54 ****
  
  /** some of the files we'll be using, where they are, and so on... **/
  
! #define  filter_temp	"/tmp/filter"
! #define  filterfile	".elm/filter-rules"
! #define  filterlog	".elm/filterlog"
! #define  filtersum	".elm/filtersum"
  
! #define  EMERGENCY_MAILBOX	"EMERGENCY_MBOX"
! #define  EMERG_MBOX		"MBOX.EMERGENCY"
  
  /** and now the hardwired constraint of the program.. **/
  
--- 42,54 ----
  
  /** some of the files we'll be using, where they are, and so on... **/
  
! #define  filter_temp	"filter"
! #define  filterfile	"elm/filter.rul"
! #define  filterlog	"elm/filter.log"
! #define  filtersum	"elm/filter.sum"
  
! #define  EMERGENCY_MAILBOX      "emergenc.mbx"
! #define  EMERG_MBOX             "emerg.mbx"
  
  /** and now the hardwired constraint of the program.. **/
  
***************
*** 87,93 ****
  
  /** A funky way to open a file using open() to avoid file locking hassles **/
  
! #define  FOLDERMODE	O_WRONLY | O_APPEND | O_CREAT | O_SYNCIO
  
  /** cheap but easy way to have two files share the same #include file **/
  
--- 87,93 ----
  
  /** A funky way to open a file using open() to avoid file locking hassles **/
  
! #define  FOLDERMODE	O_WRONLY | O_APPEND | O_CREAT
  
  /** cheap but easy way to have two files share the same #include file **/
  
***************
*** 96,101 ****
--- 96,102 ----
  char home[SLEN],				/* the users home directory */
       hostname[SLEN],			/* the machine name...      */
       username[SLEN];			/* the users login name...  */
+ char hostfromname[SLEN];                /* name of FQDN we pretend to be in */
  
  char to[VERY_LONG_STRING],
       from[LONG_STRING],
***************
*** 120,125 ****
--- 121,127 ----
  extern char home[SLEN],				/* the users home directory */
              hostname[SLEN],			/* the machine name...      */
              username[SLEN];			/* the users login name...  */
+ extern char hostfromname[SLEN];         /* name of FQDN we pretend to be in */
  
  extern char to[VERY_LONG_STRING],
              from[LONG_STRING],
diff -cbr orig/hdrs/headers.h new/hdrs/headers.h
*** orig/hdrs/headers.h	Sat Oct 16 18:43:36 1993
--- new/hdrs/headers.h	Tue Sep 28 23:25:40 1993
***************
*** 33,38 ****
--- 33,43 ----
  #include "curses.h"
  #include "defs.h"
  
+ #ifdef OS2
+ #include "../os2/os2elm.h"
+ #include <setjmp.h>
+ #endif
+ 
  #ifdef	BSD
  #include <setjmp.h>
  #endif
***************
*** 51,56 ****
--- 56,63 ----
  extern int headers_per_page;	/* number of headers/page  */
  extern int original_umask;	/* original umask, for restore before subshell */
  extern int sendmail_verbose;    /* Allow extended debugging on sendmail */
+ extern int no_save;		/* Do not save outgoing mail */
+ extern int mmdf_strict;		/* Strict MMDF mailbox scanning */
  extern char cur_folder[SLEN];	/* name of current folder */
  extern char cur_tempfolder[SLEN]; /* name of temp folder open for a mailbox */
  extern char defaultfile[SLEN];	/* name of default folder */
***************
*** 58,63 ****
--- 65,71 ----
  extern char hostname[SLEN];	/* name of machine we're on*/
  extern char hostdomain[SLEN];	/* name of domain we're in */
  extern char hostfullname[SLEN]; /* name of FQDN we're in */
+ extern char hostfromname[SLEN]; /* name of FQDN we pretend to be in */
  extern char username[SLEN];	/* return address name!    */
  extern char full_username[SLEN];/* Full username - gecos   */
  extern char home[SLEN];		/* home directory of user  */
***************
*** 172,178 ****
  extern int userid;		/* uid for current user	      */
  extern int groupid;		/* groupid for current user   */
  
! #ifdef	BSD
  extern jmp_buf GetPromptBuf;	/* setjmp buffer */
  extern int InGetPrompt;		/* set if in GetPrompt() in read() */
  #endif
--- 180,186 ----
  extern int userid;		/* uid for current user	      */
  extern int groupid;		/* groupid for current user   */
  
! #if defined(BSD) || defined(OS2)
  extern jmp_buf GetPromptBuf;	/* setjmp buffer */
  extern int InGetPrompt;		/* set if in GetPrompt() in read() */
  #endif
diff -cbr orig/hdrs/sysdefs.h new/hdrs/sysdefs.h
*** orig/hdrs/sysdefs.h	Sat Oct 16 18:43:38 1993
--- new/hdrs/sysdefs.h	Wed Sep 08 23:23:02 1993
***************
*** 91,105 ****
  
  #define emacs_editor	"emacs"
  
- #define sendmail	""
- #define smflags		"-oi -oem"	/* ignore dots and mail back errors */
- #define smflagsv      	"-oi -oem -v"   /* Verbose voyuer mode */
  #define submitmail      mailer
  #define submitflags     "-t"
! #define submitflags_s	"-mlrn"
! /* #define mailer	"rmail" */
  #define mailx		"mail"
- 
  
  #define dotelm          "elm"
  #define helphome        elmhome
--- 91,101 ----
  
  #define emacs_editor	"emacs"
  
  #define submitmail      mailer
  #define submitflags     "-t"
! #define sendmail	"sendmail"
! #define rmail		"rmail"
  #define mailx		"mail"
  
  #define dotelm          "elm"
  #define helphome        elmhome
diff -cbr orig/src/addr_util.c new/src/addr_util.c
*** orig/src/addr_util.c	Sat Oct 16 18:43:38 1993
--- new/src/addr_util.c	Wed Apr 01 12:13:50 1992
***************
*** 109,114 ****
--- 109,115 ----
       (char *) 0, 0
  };
  
+ #ifndef OS2
  char *
  gcos_name(gcos_field, logname)
  char *logname, *gcos_field;
***************
*** 169,174 ****
--- 170,176 ----
  #endif
  #endif
  }
+ #endif
  
  char *
  get_full_name(logname)
***************
*** 493,499 ****
  
  	struct header_rec temp_rec, *rec_ptr;
  	char junk[STRING], timebuff[STRING], holding_from[SLEN], hold_tz[12];
! 	char mybuf[BUFSIZ], *p, *q;
  	int  eight_fields = 0;
          int mday, month, year, minutes, seconds, tz, i;
          long gmttime;
--- 495,501 ----
  
  	struct header_rec temp_rec, *rec_ptr;
  	char junk[STRING], timebuff[STRING], holding_from[SLEN], hold_tz[12];
! 	char mybuf[BUFSIZ], timebuf2[STRING], *p, *q;
  	int  eight_fields = 0;
          int mday, month, year, minutes, seconds, tz, i;
          long gmttime;
***************
*** 509,524 ****
  
  	/* From <user> <day> <month> <day> <hr:min:sec> <year> */
  
! 	sscanf(buffer, "%*s %*s %*s %*s %*s %s %*s %s", timebuff, junk);
  
! 	if (strlen(timebuff) < 3) {
  	  dprint(3,(debugfile,
  		"Real_from returns FAIL [no time field] on\n-> %s\n",
  		buffer));
  	  return(FALSE);
  	}
  
! 	if (timebuff[1] != ':' && timebuff[2] != ':') { 
  	  dprint(3,(debugfile,
  		"Real_from returns FAIL [bad time field] on\n-> %s\n",
  		buffer));
--- 511,527 ----
  
  	/* From <user> <day> <month> <day> <hr:min:sec> <year> */
  
! 	sscanf(buffer, "%*s %*s %*s %*s %*s %s %s %s", timebuff, timebuf2, junk);
  
! 	if (strlen(timebuff) < 3 && strlen(timebuf2) < 3) {
  	  dprint(3,(debugfile,
  		"Real_from returns FAIL [no time field] on\n-> %s\n",
  		buffer));
  	  return(FALSE);
  	}
  
! 	if (timebuff[1] != ':' && timebuff[2] != ':' &&
! 	    timebuf2[1] != ':' && timebuf2[2] != ':') { /* UUPC ! */
  	  dprint(3,(debugfile,
  		"Real_from returns FAIL [bad time field] on\n-> %s\n",
  		buffer));
***************
*** 524,534 ****
  		buffer));
  	  return(FALSE);
  	}
! 	if (junk[0] != '\0') {	/* try for 8 field entry */
  	  junk[0] = '\0';
! 	  sscanf(buffer, "%*s %*s %*s %*s %*s %s %*s %*s %s", timebuff, junk);
! 	  if (junk[0] != '\0') {
! 	    dprint(3, (debugfile, 
  		  "Real_from returns FAIL [too many fields] on\n-> %s\n",
  		  buffer));
  	    return(FALSE);
--- 527,537 ----
  		buffer));
  	  return(FALSE);
  	}
! 	if (junk[0] != '\0' && strcmp(junk, "remote")) { /* try for 8 field entry */
  	  junk[0] = '\0';
! 	  sscanf(buffer, "%*s %*s %*s %*s %*s %*s %*s %*s %s", junk);
! 	  if (junk[0] != '\0' && strcmp(junk, "remote")) {
! 	    dprint(3, (debugfile,             /* ^ UUPC ! */
  		  "Real_from returns FAIL [too many fields] on\n-> %s\n",
  		  buffer));
  	    return(FALSE);
***************
*** 547,552 ****
--- 550,571 ----
  	            junk, holding_from, rec_ptr->dayname, rec_ptr->month,
                      rec_ptr->day, rec_ptr->time, rec_ptr->year);
  
+         /* non-standard UUPC From line? */
+ 
+         /* This is from UUPC rmail: */
+         /* From fkk Sat, 14 Mar 1992 14:53:27 MET remote from stasys */
+ 
+         /* while this were normal: */
+         /* From fkk Sat Mar 14 14:53:27 1992 [MET] */
+ 
+         if ( rec_ptr->dayname[strlen(rec_ptr->dayname) - 1] == ',' )
+         {
+ 	  sscanf(buffer, "%s %s %s %s %s %s %s %s",
+ 	         junk, holding_from, rec_ptr->dayname, rec_ptr->day,
+                  rec_ptr->month, rec_ptr->year, rec_ptr->time, hold_tz);
+           rec_ptr->dayname[strlen(rec_ptr->dayname) - 1] = 0;
+         }
+ 
  	strncpy(rec_ptr->from, holding_from, STRING-1);
  	rec_ptr->from[STRING-1] = '\0';
  	resolve_received(rec_ptr);
***************
*** 815,821 ****
  /* Return smallest i such that table[i] is a prefix of str.  Return -1 if not
   * found.
   */
! static int prefix(table, str)
  char **table;
  char *str;
  {
--- 834,840 ----
  /* Return smallest i such that table[i] is a prefix of str.  Return -1 if not
   * found.
   */
! int prefix(table, str)
  char **table;
  char *str;
  {
***************
*** 925,931 ****
   * Unlike the preceding routines, the result is not an updated pointer, but
   * simply 1 for success and 0 for failure.
   */
! static int
  get_unix_date(p,y,d,m,s,t)
  char *p;
  int *y, *d, *m, *s, *t;
--- 944,950 ----
   * Unlike the preceding routines, the result is not an updated pointer, but
   * simply 1 for success and 0 for failure.
   */
! int
  get_unix_date(p,y,d,m,s,t)
  char *p;
  int *y, *d, *m, *s, *t;
diff -cbr orig/src/alias.c new/src/alias.c
*** orig/src/alias.c	Sat Oct 16 18:43:40 1993
--- new/src/alias.c	Sun Oct 04 14:35:04 1992
***************
*** 44,50 ****
--- 44,52 ----
  char *get_alias_address();
  char *error_name(), *error_description(), *strip_parens(), *index();
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  #ifndef DONT_TOUCH_ADDRESSES
  char *expand_system();
***************
*** 80,90 ****
  
  	struct stat hst;
  	static time_t system_ctime, system_mtime;
  
  	/* If hash file hasn't changed, don't bother re-reading. */
  
  	if (system_data != -1
! 	 && stat(system_hash_file, &hst) == 0
  	 && hst.st_ctime == system_ctime
  	 && hst.st_mtime == system_mtime)
  	  return;
--- 82,95 ----
  
  	struct stat hst;
  	static time_t system_ctime, system_mtime;
+         char syshash[SLEN], sysdata[SLEN];
  
  	/* If hash file hasn't changed, don't bother re-reading. */
+         sprintf(syshash, "%s/%s", elmhome, system_hash_file);
+         sprintf(sysdata, "%s/%s", elmhome, system_data_file);
  
  	if (system_data != -1
! 	 && stat(syshash, &hst) == 0
  	 && hst.st_ctime == system_ctime
  	 && hst.st_mtime == system_mtime)
  	  return;
***************
*** 98,113 ****
  
  	/* Read system hash table.  If we can't, just return. */
  
! 	if (read_hash_file(system_hash_file, (char *) system_hash_table,
  			    sizeof system_hash_table) < 0)
  	  return;
  
  	/* Open system data table. */
  
! 	if ((system_data = open(system_data_file, O_RDONLY)) == -1) {
  	  dprint(1, (debugfile,
  		      "Warning: Can't open system alias data file %s\n",
! 		      system_data_file));
  	  return;
  	}
  
--- 103,118 ----
  
  	/* Read system hash table.  If we can't, just return. */
  
! 	if (read_hash_file(syshash, (char *) system_hash_table,
  			    sizeof system_hash_table) < 0)
  	  return;
  
  	/* Open system data table. */
  
! 	if ((system_data = open(sysdata, O_RDONLY)) == -1) {
  	  dprint(1, (debugfile,
  		      "Warning: Can't open system alias data file %s\n",
! 		      sysdata));
  	  return;
  	}
  
***************
*** 396,402 ****
  	FILE *file;
  	char fname[SLEN];
  
! 	sprintf(fname,"%s/%s", home, ALIAS_TEXT);
  
  	save_file_stats(fname);
  	if ((file = fopen(fname, "a")) == NULL) {
--- 401,407 ----
  	FILE *file;
  	char fname[SLEN];
  
! 	sprintf(fname, "%s/%s", home, ALIAS_TEXT);
  
  	save_file_stats(fname);
  	if ((file = fopen(fname, "a")) == NULL) {
***************
*** 441,448 ****
  	strcpy(name_with_equals, name);
  	strcat(name_with_equals, " =");
  
! 	sprintf(fname,"%s/%s", home, ALIAS_TEXT);
! 	sprintf(tmpfname,"%s/%s.t", home, ALIAS_TEXT);
  
  	save_file_stats(fname);
  
--- 446,453 ----
  	strcpy(name_with_equals, name);
  	strcat(name_with_equals, " =");
  
! 	sprintf(fname, "%s/%s", home, ALIAS_TEXT);
! 	sprintf(tmpfname, "%s/%s", home, ALIAS_TEMP);
  
  	save_file_stats(fname);
  
***************
*** 485,490 ****
--- 490,496 ----
  	}
  	fclose(file);
  	fclose(tmp_file);
+         unlink(fname);
  	if (rename(tmpfname, fname) != 0)
  	{
  		error1("Couldn't rename tempfile %s after deleting alias!", tmpfname);
***************
*** 498,504 ****
  
  show_alias_menu()
  {
! 	MoveCursor(LINES-7,0); CleartoEOS();	
  
  	PutLine0(LINES-7,COLUMNS-45, "Alias commands");
  	Centerline(LINES-6,
--- 504,510 ----
  
  show_alias_menu()
  {
! 	MoveCursor(LINES-8,0); CleartoEOS();
  
  	PutLine0(LINES-7,COLUMNS-45, "Alias commands");
  	Centerline(LINES-6,
***************
*** 645,658 ****
  	/** run the 'newalias' program and update the
  	    aliases before going back to the main program!
  	**/
! 
  
  	error("Updating aliases...");
! 	sleep(2);
  
! 	if (system_call(newalias, SH, FALSE, FALSE) == 0) {
  	  error("Re-reading the database in...");
! 	  sleep(2);
  	  read_alias_files();
  	  set_error("Aliases updated successfully.");
  	}
--- 651,665 ----
  	/** run the 'newalias' program and update the
  	    aliases before going back to the main program!
  	**/
!         char cmd[SLEN];
  
  	error("Updating aliases...");
! 	/* sleep(2); */
!         sprintf(cmd, "%s", newalias);
  
! 	if (system_call(cmd, SH, FALSE, FALSE) == 0) {
  	  error("Re-reading the database in...");
! 	  /* sleep(2); */
  	  read_alias_files();
  	  set_error("Aliases updated successfully.");
  	}
***************
*** 722,728 ****
  {
  	char fname[SLEN];
  
! 	sprintf(fname,"%s/%s", home, ALIAS_TEXT);
  	display_file(fname);
  	ClearScreen();
  	return;
--- 729,735 ----
  {
  	char fname[SLEN];
  
! 	sprintf(fname, "%s/%s", home, ALIAS_TEXT);
  	display_file(fname);
  	ClearScreen();
  	return;
diff -cbr orig/src/aliasdb.c new/src/aliasdb.c
*** orig/src/aliasdb.c	Sat Oct 16 18:43:40 1993
--- new/src/aliasdb.c	Mon Mar 16 09:47:44 1992
***************
*** 35,41 ****
--- 35,43 ----
  #include <sys/stat.h>
  #include <errno.h>
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  #ifdef USE_DBM
  # include <dbm.h>
***************
*** 324,338 ****
  
  	struct stat buffer;
  	char   *path_filename;
- 
- #ifdef USE_DBM
  	char buf[BUFSIZ];
  
! 	sprintf(buf,"%s.pag", pathfile);
! 	path_filename = buf;
  #else
! 	path_filename = pathfile;
  #endif
  
  	if (stat(path_filename, &buffer) == -1) {
  	  dprint(2, (debugfile,
--- 326,339 ----
  
  	struct stat buffer;
  	char   *path_filename;
  	char buf[BUFSIZ];
  
! #ifdef USE_DBM
! 	sprintf(buf,"%s/%s.pag", elmhome, pathfile);
  #else
! 	sprintf(buf,"%s/%s", elmhome, pathfile);
  #endif
+ 	path_filename = buf;
  
  	if (stat(path_filename, &buffer) == -1) {
  	  dprint(2, (debugfile,
diff -cbr orig/src/args.c new/src/args.c
*** orig/src/args.c	Sat Oct 16 18:43:40 1993
--- new/src/args.c	Sun Aug 16 22:56:28 1992
***************
*** 51,57 ****
  	to_whom[0] = '\0';
  	batch_subject[0] = '\0';
  
!         while ((c = getopt(argc, argv, "?acd:f:hkKms:Vvwz")) != EOF) {
  	   switch (c) {
  	     case 'a' : arrow_cursor++;		break;
  	     case 'c' : check_only++;		break;
--- 51,57 ----
  	to_whom[0] = '\0';
  	batch_subject[0] = '\0';
  
!         while ((c = getopt(argc, argv, "?acd:f:hkKmns:uVvwz")) != EOF) {
  	   switch (c) {
  	     case 'a' : arrow_cursor++;		break;
  	     case 'c' : check_only++;		break;
***************
*** 62,68 ****
--- 62,70 ----
  	     case 'k' : hp_terminal++;	break;
  	     case 'K' : hp_terminal++; hp_softkeys++;	break;
  	     case 'm' : mini_menu = 0;	break;
+ 	     case 'n' : no_save++;	break;
  	     case 's' : strcpy(batch_subject, optarg);	break;
+ 	     case 'u' : mmdf_strict++;	break; /* i.e. UUPC */
               case 'V' : sendmail_verbose++;     break;
  	     case 'v' : args_version();
  	     case 'w' : warnings = 0;	break;
***************
*** 122,128 ****
--- 124,132 ----
  	printf("\t -k \t\tKeypad - enable HP 2622 terminal keyboard\n");
  	printf("\t -K \t\tKeypad&softkeys - enable use of softkeys + \"-k\"\n");
  	printf("\t -m \t\tMenu - Turn off menu, using more of the screen\n");
+ 	printf("\t -n \t\tNosave - Do not save outgoing mail - for batchmailing\n");
  	printf("\t -sx\t\tSubject 'x' - for batchmailing\n");
+ 	printf("\t -u \t\tMore restrictive mailbox scanning - for UUPC mailboxes\n");
          printf("\t -V \t\tEnable sendmail voyeur mode.\n");
  	printf("\t -v \t\tPrint out ELM version information.\n");
  	printf("\t -w \t\tSupress warning messages...\n");
diff -cbr orig/src/builtin.c new/src/builtin.c
*** orig/src/builtin.c	Sat Oct 16 18:43:40 1993
--- new/src/builtin.c	Sun Mar 29 00:05:02 1992
***************
*** 78,84 ****
  	 * is removed from input and 1 is returned. Otherwise 0 is returned.
  	 */
  
! 	register char *optr, *iptr;
  	register unsigned chars_output, nt;
  	int ret_val;
  
--- 78,84 ----
  	 * is removed from input and 1 is returned. Otherwise 0 is returned.
  	 */
  
! 	register unsigned char *optr, *iptr;
  	register unsigned chars_output, nt;
  	int ret_val;
  
***************
*** 98,105 ****
  	      iptr++;
  	    break;
  	  } else if (*iptr == '\n' || *iptr == '\r') {	/*newline or return */
- 	    *optr++ = '\n';
  	    *optr++ = '\r';
  	    iptr++;
  	    break;			/* end of line */
  	  } else if(*iptr == '\f') {		/* formfeed */
--- 98,105 ----
  	      iptr++;
  	    break;
  	  } else if (*iptr == '\n' || *iptr == '\r') {	/*newline or return */
  	    *optr++ = '\r';
+ 	    *optr++ = '\n';
  	    iptr++;
  	    break;			/* end of line */
  	  } else if(*iptr == '\f') {		/* formfeed */
***************
*** 113,120 ****
  	    break;
  	  } else if(*iptr == '\t') {		/* tab stop */
  	    if((nt=next_tab(chars_output+1)) > width) {
! 	      *optr++ = '\n';		/* won't fit on this line - autowrap */
! 	      *optr++ = '\r';		/* tab by tabbing so-to-speak to 1st */
  	      iptr++;			/* column of next line */
  	      break;
  	    } else {		/* will fit - output proper num of spaces */
--- 113,122 ----
  	    break;
  	  } else if(*iptr == '\t') {		/* tab stop */
  	    if((nt=next_tab(chars_output+1)) > width) {
! #ifndef OS2
! 	      *optr++ = '\r';		/* won't fit on this line - autowrap */
! 	      *optr++ = '\n';		/* tab by tabbing so-to-speak to 1st */
! #endif
  	      iptr++;			/* column of next line */
  	      break;
  	    } else {		/* will fit - output proper num of spaces */
***************
*** 126,132 ****
--- 126,136 ----
  	      }
  	      iptr++;
  	    }
+ #ifdef OS2
+ 	  } else if(isprint(*iptr) || (128 <= *iptr && *iptr < 255)) {
+ #else
  	  } else if(isprint(*iptr)) {
+ #endif
  	    *optr++ = *iptr++;			/* printing character */
  	    chars_output++;
  	  } else {			/* non-white space control character */
***************
*** 161,166 ****
--- 163,170 ----
  	char *pending, footer[SLEN], display_buffer[SLEN], ch;
  	int formfeed, lines_more;
  
+         fixline(input_line);
+ 
  #ifdef MMDF
  	if (strcmp(input_line, MSG_SEPERATOR) == 0)
  	  strcpy(input_line," ");
***************
*** 291,297 ****
  
  	/* truncate or pad title2 portion on the right
  	 * so that line fits exactly to the rightmost column */
! 	padding = COLUMNS - (t1_len + t2_len + strlen(title3));
  
  	sprintf(titlebuf, "%s%-*.*s%s\n\r\n\r", title1, t2_len+padding,
  	    t2_len+padding, title2, title3);
--- 295,301 ----
  
  	/* truncate or pad title2 portion on the right
  	 * so that line fits exactly to the rightmost column */
! 	padding = COLUMNS - 1 - (t1_len + t2_len + strlen(title3));
  
  	sprintf(titlebuf, "%s%-*.*s%s\n\r\n\r", title1, t2_len+padding,
  	    t2_len+padding, title2, title3);
diff -cbr orig/src/calendar.c new/src/calendar.c
*** orig/src/calendar.c	Sat Oct 16 18:43:40 1993
--- new/src/calendar.c	Sun Mar 29 00:05:10 1992
***************
*** 43,49 ****
--- 43,51 ----
  
  #include <errno.h>
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *error_description(), *strcpy();
  
diff -cbr orig/src/conn_to.c new/src/conn_to.c
*** orig/src/conn_to.c	Sat Oct 16 18:43:42 1993
--- new/src/conn_to.c	Sun Mar 15 14:17:04 1992
***************
*** 56,62 ****
  	  return;
  	}
  
! 	sprintf(filename, "%s%s%d", temp_dir, temp_uuname, getpid());
  	sprintf(buffer,"%s > %s", uuname, filename);
  
  	if (system_call(buffer, SH, FALSE, FALSE) != 0) {
--- 56,62 ----
  	  return;
  	}
  
! 	sprintf(filename, "%s%d%s", temp_dir, getpid(), temp_uuname);
  	sprintf(buffer,"%s > %s", uuname, filename);
  
  	if (system_call(buffer, SH, FALSE, FALSE) != 0) {
diff -cbr orig/src/curses.c new/src/curses.c
*** orig/src/curses.c	Sat Oct 16 18:43:42 1993
--- new/src/curses.c	Sat Oct 16 13:27:28 1993
***************
*** 119,127 ****
       *_setbold, *_clearbold, *_setunderline, *_clearunderline,
       *_sethalfbright, *_clearhalfbright, *_setinverse, *_clearinverse,
       *_cleartoeoln, *_cleartoeos, *_transmit_on, *_transmit_off,
!      *_set_memlock, *_clear_memlock;
  
! static int _lines, _columns, _automargin, _eatnewlineglitch;
  int tabspacing;
  
  static char _terminal[1024];              /* Storage for terminal entry */
--- 119,127 ----
       *_setbold, *_clearbold, *_setunderline, *_clearunderline,
       *_sethalfbright, *_clearhalfbright, *_setinverse, *_clearinverse,
       *_cleartoeoln, *_cleartoeos, *_transmit_on, *_transmit_off,
!      *_set_memlock, *_clear_memlock, *_initscreen, *_exitscreen;
  
! static int _lines, _columns, _automargin, _eatnewlineglitch, initialized;
  int tabspacing;
  
  static char _terminal[1024];              /* Storage for terminal entry */
***************
*** 145,154 ****
  	char termname[40];
  	char *strcpy(), *getenv();
  
! 	if (getenv("TERM") == NULL) return(-1);
! 
! 	if (strcpy(termname, getenv("TERM")) == NULL)
! 		return(-1);
  
  	if ((err = tgetent(_terminal, termname)) != 1)
  		return(err-2);
--- 145,154 ----
  	char termname[40];
  	char *strcpy(), *getenv();
  
! 	if (getenv("TERM") == NULL)
! 	        strcpy(termname, "ansi");
!         else
! 		strcpy(termname, getenv("TERM"));
  
  	if ((err = tgetent(_terminal, termname)) != 1)
  		return(err-2);
***************
*** 157,162 ****
--- 157,164 ----
  	_col   =  0;		/* assume zero, zero...     */
  
  	/* load in all those pesky values */
+ 	_initscreen        = tgetstr("ti", &ptr);
+ 	_exitscreen        = tgetstr("te", &ptr);
  	_clearscreen       = tgetstr("cl", &ptr);
  	_moveto            = tgetstr("cm", &ptr);
  	_up                = tgetstr("up", &ptr);
***************
*** 188,196 ****
--- 190,214 ----
  		_left = "\b";
  	}
  
+ 	tputs(_initscreen, 1, outchar);
+ 	fflush(stdout);
+         initialized = 1;
+ 
  	return(0);
  }
  
+ ExitScreen()
+ {
+         if ( initialized )
+         {
+ 		tputs(_exitscreen, 1, outchar);
+ #ifdef OS2
+ 	        tflush();
+ #endif
+ 		fflush(stdout);
+         }
+ }
+ 
  char *return_value_of(termcap_label)
  char *termcap_label;
  {
***************
*** 268,273 ****
--- 283,291 ----
  {
  	/** returns the number of lines and columns on the display. **/
  
+ #ifdef OS2
+         _ScreenSize(&_lines, &_columns);
+ #endif
  #ifdef TIOCGWINSZ
  	struct winsize w;
  
***************
*** 717,726 ****
--- 717,730 ----
  
  	else {
  	  /* if some kind of non-printable character change to a '?' */
+ #ifdef OS2
+ 	  if(!isprint(ch) && !(128 <= ch && ch < 255))
+ #else
  #ifdef ASCII_CTYPE
  	  if(!isascii(ch) || !isprint(ch))
  #else
  	  if(!isprint(ch))
+ #endif
  #endif
  	    ch = '?';
  
***************
*** 838,844 ****
--- 856,874 ----
  	/** clear to end of screen **/
  
  	if (!_cleartoeos)
+ #ifdef OS2
+         {
+           int i;
+ 	    tflush();
+           printf("\033[s\033[K");
+           for ( i = _line + 1; i < _lines; i++ )
+             printf("\033[%d;1H\033[K", i + 1);
+           printf("\033[u");
+           fflush(stdout);
+         }
+ #else
  		return(-1);
+ #endif
  
  	tputs(_cleartoeos, 1, outchar);
  	fflush(stdout);  /* clear the output buffer */
***************
*** 861,866 ****
--- 890,899 ----
  	if (state == OFF && _inraw) {
  	  (void) ttsetattr(TTYIN,&_original_tty);
  	  _inraw = 0;
+ #ifdef OS2
+ 	    tflush();
+           _fsetmode(stdout, "t");
+ #endif
  	}
  	else if (state == ON && ! _inraw) {
  
***************
*** 879,886 ****
--- 911,934 ----
  #endif
  	  (void) ttsetattr(TTYIN, &_raw_tty);
  	  _inraw = 1;
+ #ifdef OS2
+           _fsetmode(stdout, "b");
+ #endif
+ 	}
+ }
+ 
+ #ifdef OS2
+ char cbuffer[1024];
+ int cbufsize;
+ 
+ tflush()
+ {
+         if ( cbufsize ) {
+           fwrite(cbuffer, cbufsize, 1, stdout);
+           cbufsize = 0;
          }
  }
+ #endif
  
  int
  ReadCh()
***************
*** 889,896 ****
--- 937,949 ----
  
  	register int result;
  	char ch;
+ #ifdef OS2
+         tflush();
+         return readkey();
+ #else
  	result = read(0, &ch, 1);
          return((result <= 0 ) ? EOF : ch);
+ #endif
  }
  
  outchar(c)
***************
*** 899,904 ****
--- 952,964 ----
  	/** output the given character.  From tputs... **/
  	/** Note: this CANNOT be a macro!              **/
  
+ #ifdef OS2
+         cbuffer[cbufsize++] = c;
+ 
+         if ( cbufsize == sizeof(cbuffer) )
+           tflush();
+ #else
  	putc(c, stdout);
+ #endif
  }
  
diff -cbr orig/src/date.c new/src/date.c
*** orig/src/date.c	Sat Oct 16 18:43:42 1993
--- new/src/date.c	Wed Feb 09 19:38:30 1994
***************
*** 40,47 ****
  #include <ctype.h>
  
  #ifndef	_POSIX_SOURCE
! extern struct tm *localtime();
! extern long	  time();
  #endif
  
  #ifdef BSD
--- 40,47 ----
  #include <ctype.h>
  
  #ifndef	_POSIX_SOURCE
! extern struct tm *localtime(), *gmtime();
! extern time_t	  time();
  #endif
  
  #ifdef BSD
***************
*** 66,96 ****
  int  days_in_month[] = { 31,    28,    31,    30,    31,     30,
  		  31,     31,    30,   31,    30,     31,  -1};
  
! #ifdef BSD
!   char *timezone();
! #else
!   extern char *tzname[];
! #endif
  
  char *get_arpa_date()
  {
  	/** returns an ARPA standard date.  The format for the date
! 	    according to DARPA document RFC-822 is exemplified by;
  
! 	       	      Mon, 12 Aug 85 6:29:08 MST
  
  	**/
  
  	static char buffer[SLEN];	/* static character buffer       */
! 	struct tm *the_time;		/* Time structure, see CTIME(3C) */
  	long	   junk;		/* time in seconds....		 */
  
  #ifdef BSD
  # ifndef TZ_MINUTESWEST
- 	struct timeb	loc_time;
- 
  	junk = time((long *) 0);
- 	ftime(&loc_time);
  # else
  	struct  timeval  time_val;
  	struct  timezone time_zone;
--- 66,96 ----
  int  days_in_month[] = { 31,    28,    31,    30,    31,     30,
  		  31,     31,    30,   31,    30,     31,  -1};
  
! char *tzoffset(long time)
! {
!   static char offset[SLEN];
!   struct tm tm = *localtime(&time);
!   long utime = mktime(&tm);
!   sprintf(offset, "%+03d00", (utime - time) / 3600);
!   return offset;
! }
  
  char *get_arpa_date()
  {
  	/** returns an ARPA standard date.  The format for the date
! 	    according to DARPA document RFC-822 is exemplified by:
  
! 	       	      Mon, 12 Aug 85 6:29:08 -0800
  
  	**/
  
  	static char buffer[SLEN];	/* static character buffer       */
! 	struct tm the_time;		/* Time structure, see CTIME(3C) */
  	long	   junk;		/* time in seconds....		 */
  
  #ifdef BSD
  # ifndef TZ_MINUTESWEST
  	junk = time((long *) 0);
  # else
  	struct  timeval  time_val;
  	struct  timezone time_zone;
***************
*** 103,131 ****
  	junk = time((long *) 0);	/* this must be here for it to work! */
  #endif
  
! 	the_time = localtime(&junk);
  
  	sprintf(buffer, "%s, %d %s %d %d:%02d:%02d %s",
! 	  arpa_dayname[the_time->tm_wday],
! 	  the_time->tm_mday % 32,
! 	  arpa_monname[the_time->tm_mon],
! 	  the_time->tm_year % 100,
! 	  the_time->tm_hour % 24,
! 	  the_time->tm_min  % 61,
! 	  the_time->tm_sec  % 61,
! #ifdef BSD
! #ifdef TZ_MINUTESWEST
! # ifdef GOULD_NP1
! 	  the_time->tm_zone);
! # else
! 	  timezone(time_zone.tz_minuteswest, the_time->tm_isdst));
! # endif
! #else
! 	  timezone(loc_time.timezone, the_time->tm_isdst));
! #endif
! #else
! 	  tzname[the_time->tm_isdst]);
! #endif
  
  	return( (char *) buffer);
  }
--- 103,119 ----
  	junk = time((long *) 0);	/* this must be here for it to work! */
  #endif
  
! 	the_time = *localtime(&junk);
  
  	sprintf(buffer, "%s, %d %s %d %d:%02d:%02d %s",
! 	  arpa_dayname[the_time.tm_wday],
! 	  the_time.tm_mday % 32,
! 	  arpa_monname[the_time.tm_mon],
! 	  the_time.tm_year % 100,
! 	  the_time.tm_hour % 24,
! 	  the_time.tm_min  % 61,
! 	  the_time.tm_sec  % 61,
! 	  tzoffset(junk));
  
  	return( (char *) buffer);
  }
diff -cbr orig/src/domains.c new/src/domains.c
*** orig/src/domains.c	Sat Oct 16 18:43:42 1993
--- new/src/domains.c	Mon Mar 16 09:48:44 1992
***************
*** 67,75 ****
  
  open_domain_file()
  {
! 	if ((domainfd = fopen(domains, "r")) == NULL) {
  	  dprint(2, (debugfile,"Warning: can't open file %s as domains file\n",
! 		domains));
  	}
  	else {
  	  dprint(3, (debugfile,
--- 67,79 ----
  
  open_domain_file()
  {
!         char domainsfile[SLEN];
! 
!         sprintf(domainsfile, "%s/%s", elmhome, domains);
! 
! 	if ((domainfd = fopen(domainsfile, "r")) == NULL) {
  	  dprint(2, (debugfile,"Warning: can't open file %s as domains file\n",
! 		domainsfile));
  	}
  	else {
  	  dprint(3, (debugfile,
diff -cbr orig/src/edit.c new/src/edit.c
*** orig/src/edit.c	Sat Oct 16 18:43:44 1993
--- new/src/edit.c	Wed Nov 17 10:44:46 1993
***************
*** 38,44 ****
--- 38,46 ----
  #include "headers.h"
  #include <errno.h>
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char   *error_name(), *error_description(), *strcpy();
  long   bytes();
***************
*** 83,88 ****
--- 85,95 ----
  
  	Raw(OFF);
  
+ 	fclose(mailfile);
+ 	mailfile = NULL;
+ 
+         os2path(buffer);
+         
  	if (system_call(buffer, SH, TRUE, FALSE) != 0) {
  	  error1("Problems invoking editor %s!", alternative_editor);
  	  Raw(ON);
***************
*** 91,96 ****
--- 98,104 ----
  	}
  
  	Raw(ON);
+         ClearScreen();
  	SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
  
  	if (folder_type == SPOOL) {	/* uh oh... now the toughie...  */
***************
*** 192,198 ****
  	} else
  	  error("Resynchronizing with new version of folder...");
  
! 	sleep(2);
  	ClearScreen();
  	newmbox(cur_folder, FALSE);
  	showscreen();
--- 200,206 ----
  	} else
  	  error("Resynchronizing with new version of folder...");
  
! 	/* sleep(2); */
  	ClearScreen();
  	newmbox(cur_folder, FALSE);
  	showscreen();
diff -cbr orig/src/editmsg.c new/src/editmsg.c
*** orig/src/editmsg.c	Sat Oct 16 18:43:44 1993
--- new/src/editmsg.c	Tue Dec 14 21:46:06 1993
***************
*** 55,61 ****
--- 55,63 ----
  #undef        tolower
  #endif
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *error_description(), *strcpy(), *format_long();
  unsigned long sleep();
***************
*** 86,91 ****
--- 88,94 ----
          if (strlen(buffer) == 0)
            sprintf(buffer,"%s %s", editor, filename);
  
+ 	os2path(buffer);
  	chown(filename, userid, groupid);	/* file was owned by root! */
  
  	if (( old_raw = RawState()) == ON)
***************
*** 109,114 ****
--- 112,118 ----
  	if (old_raw == ON)
  	   Raw(ON);
  
+         ClearScreen();
  	SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
  	MoveCursor(LINES, 0);	/* dont know where we are, force last row, col 0 */
  
***************
*** 286,299 ****
  			     Write_to_screen(
  		 "(You need to use a specific command here. Continue.)\n\r");
  			   else {
! 			     sprintf(buf, " > %s%s.%d 2>&1", temp_dir, temp_edit, getpid());
  			     strcat(buffer, buf);
  			     if (( old_raw = RawState()) == ON)
  			       Raw(OFF);
  			     (void) system_call((char *) buffer+2, SH, TRUE, TRUE);
  			     if (old_raw == ON)
  			        Raw(ON);
! 			     sprintf(buffer, "~r %s%s.%d", temp_dir, temp_edit, getpid());
  	      	             read_in_file(edit_fd, (char *) buffer + 3, 0);
  			     (void) unlink((char *) buffer+3);
  			     SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
--- 290,303 ----
  			     Write_to_screen(
  		 "(You need to use a specific command here. Continue.)\n\r");
  			   else {
! 			     sprintf(buf, " > %s%d.%s", temp_dir, getpid(), temp_edit);
  			     strcat(buffer, buf);
  			     if (( old_raw = RawState()) == ON)
  			       Raw(OFF);
  			     (void) system_call((char *) buffer+2, SH, TRUE, TRUE);
  			     if (old_raw == ON)
  			        Raw(ON);
! 			     sprintf(buffer, "~r %s%d.%s", temp_dir, getpid(), temp_edit);
  	      	             read_in_file(edit_fd, (char *) buffer + 3, 0);
  			     (void) unlink((char *) buffer+3);
  			     SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
***************
*** 359,365 ****
  
  	char	buf[SLEN];
  
! 	Write_to_screen("\n\r(Available options at this point are:\n\r\n\r", 0);
  	sprintf(buf, "\t%c?\tPrint this help menu.\n\r", escape_char);
  	Write_to_screen(buf, 0);
  	if (escape_char == TILDE_ESCAPE) /* doesn't make sense otherwise... */
--- 363,369 ----
  
  	char	buf[SLEN];
  
! 	Write_to_screen("\n\rAvailable options at this point are:\n\r\n\r", 0);
  	sprintf(buf, "\t%c?\tPrint this help menu.\n\r", escape_char);
  	Write_to_screen(buf, 0);
  	if (escape_char == TILDE_ESCAPE) /* doesn't make sense otherwise... */
***************
*** 423,429 ****
  	sprintf(buf,
        "\t.  \tby itself on a line (or a control-D) ends the message.\n\r");
  	Write_to_screen(buf, 0);
! 	Write_to_screen("Continue.)\n\r", 0);
  }
  
  read_in_file(fd, filename, show_user_filename)
--- 427,433 ----
  	sprintf(buf,
        "\t.  \tby itself on a line (or a control-D) ends the message.\n\r");
  	Write_to_screen(buf, 0);
! 	Write_to_screen("(Continue.)\n\r", 0);
  }
  
  read_in_file(fd, filename, show_user_filename)
diff -cbr orig/src/elm.c new/src/elm.c
*** orig/src/elm.c	Sat Oct 16 18:43:44 1993
--- new/src/elm.c	Sat Oct 02 09:54:00 1993
***************
*** 53,59 ****
--- 53,63 ----
  	     last_in_folder;	/** for when we receive new mail too...      **/
  	long num;		/** another variable for fun..               **/
  	extern char version_buff[];
+ #ifndef OS2
  	extern int errno;
+ #endif
+ 
+         initpaths();
  
  	req_mfile = parse_arguments(argc, argv, to_whom);
  
***************
*** 82,87 ****
--- 86,92 ----
  	  redraw = 0;
  	  nufoot = 0;
  	  nucurr = 0;
+ 	  /* move_incoming_mail(); */
  	  if ((num = bytes(cur_folder)) != mailfile_size) {
  	    dprint(2, (debugfile, "Just received %d bytes more mail (elm)\n",
  		    num - mailfile_size));
***************
*** 512,517 ****
--- 512,518 ----
  	    case '>'    : /** backwards compatibility **/
  
  	    case 'C'	:
+ 	    case 'S'	:
  	    case 's'    :  if  (message_count < 1) {
  			     error1("No mail to %s!",
  			       ch != 'C' ? "save" : "copy");
***************
*** 523,529 ****
  				      ch != 'C' ? "Save" : "Copy");
  			     PutLine0(LINES-3,COLUMNS-40,
  				"(Use '?' to list your folders)");
! 			     if (save(&redraw, FALSE, (ch != 'C'))
  				 && resolve_mode && ch != 'C') {
  			       if((i=next_message(current-1, TRUE)) != -1) {
  				 current = i+1;
--- 524,530 ----
  				      ch != 'C' ? "Save" : "Copy");
  			     PutLine0(LINES-3,COLUMNS-40,
  				"(Use '?' to list your folders)");
! 			     if (save(&redraw, FALSE, ch)
  				 && resolve_mode && ch != 'C') {
  			       if((i=next_message(current-1, TRUE)) != -1) {
  				 current = i+1;
***************
*** 720,731 ****
  	ClearScreen();
  	Raw(OFF);
  
! 	PutLine2(0,0,"Current message number = %d\t\t%d message(s) total\n",
  		current, message_count);
! 	PutLine2(2,0,"Header_page = %d           \t\t%d possible page(s)\n",
  		header_page, (int) (message_count / headers_per_page) + 1);
  
! 	PutLine1(4,0,"\nCurrent mailfile is %s.\n\n", cur_folder);
  
  	i = header_page*headers_per_page;	/* starting header */
  
--- 725,736 ----
  	ClearScreen();
  	Raw(OFF);
  
! 	PutLine2(0,0,"Current message number = %d\t\t%d message(s) total\r\n",
  		current, message_count);
! 	PutLine2(2,0,"Header_page = %d           \t\t%d possible page(s)\r\n",
  		header_page, (int) (message_count / headers_per_page) + 1);
  
! 	PutLine1(4,0,"\r\nCurrent mailfile is %s.\n\r\n\r", cur_folder);
  
  	i = header_page*headers_per_page;	/* starting header */
  
***************
*** 737,743 ****
  
  	while (i <= j) {
  	   sprintf(buffer,
! 	   "%3d  %-16.16s  %-40.40s  %4d  %d\n\r",
  		    i+1,
  		    headers[i]->from,
  		    headers[i]->subject,
--- 742,748 ----
  
  	while (i <= j) {
  	   sprintf(buffer,
! 	   "%3d  %-16.16s  %-40.40s  %4d  %ld\n\r",
  		    i+1,
  		    headers[i]->from,
  		    headers[i]->subject,
***************
*** 837,841 ****
  	dprint(3, (debugfile, "Check-only: checking \n-> \"%s\"\n",
  		format_long(to_whom, 3)));
  	(void) build_address(strip_commas(to_whom), buffer);
! 	printf("Expands to: %s", format_long(buffer, strlen("Expands to: ")));
  	}
--- 842,846 ----
  	dprint(3, (debugfile, "Check-only: checking \n-> \"%s\"\n",
  		format_long(to_whom, 3)));
  	(void) build_address(strip_commas(to_whom), buffer);
! 	printf("\r\nExpands to: %s\r\n", format_long(buffer, strlen("Expands to: ")));
  	}
diff -cbr orig/src/expires.c new/src/expires.c
*** orig/src/expires.c	Sat Oct 16 18:43:46 1993
--- new/src/expires.c	Sun Oct 04 09:58:02 1992
***************
*** 52,58 ****
  	int  month = 0, day = 0, year = 0, hour = 0, minute = 0;
  #ifndef	_POSIX_SOURCE
  	struct tm *localtime();
! 	long time();
  #endif
  
  	/** first step is to break down the date given into MM DD YY HH MM
--- 52,58 ----
  	int  month = 0, day = 0, year = 0, hour = 0, minute = 0;
  #ifndef	_POSIX_SOURCE
  	struct tm *localtime();
! 	time_t time();
  #endif
  
  	/** first step is to break down the date given into MM DD YY HH MM
diff -cbr orig/src/file.c new/src/file.c
*** orig/src/file.c	Sat Oct 16 18:43:46 1993
--- new/src/file.c	Sun Aug 22 09:19:44 1993
***************
*** 42,48 ****
--- 42,50 ----
  #undef tolower
  #endif
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *error_description(), *strcpy(), *getenv(), *nameof();
  unsigned long sleep();
***************
*** 50,57 ****
  unsigned long sleep();
  
  int
! save(redraw, silently, delete)
! int *redraw, silently, delete;
  {
  	/** Save all tagged messages + current in a folder.  If no messages
  	    are tagged, save the current message instead!  This routine
--- 50,57 ----
  unsigned long sleep();
  
  int
! save(redraw, silently, type)
! int *redraw, silently, type;
  {
  	/** Save all tagged messages + current in a folder.  If no messages
  	    are tagged, save the current message instead!  This routine
***************
*** 69,74 ****
--- 69,76 ----
  	char filename[SLEN], address[LONG_STRING], buffer[LONG_STRING];
  	static char helpmsg[LONG_STRING];
  	FILE *save_file;
+ 	int delete = (type != 'C');
+ 	int reverse = (type == 'S');
  
  	oldstat = headers[current-1]->status;	/* remember */
  	*redraw = FALSE;
***************
*** 98,103 ****
--- 100,110 ----
  
  	  if (save_by_name) {
  	    /** build default filename to save to **/
+ 	    if (reverse) {
+ 	      get_existing_address(buffer, mesgnum);
+ 	      strcpy(address, strip_parens(buffer));
+ 	    } 
+ 	    else
  	      get_return(address, mesgnum);
  	    get_return_name(address, buffer, TRUE);
  	    sprintf(filename, "=%s", buffer);
***************
*** 225,231 ****
  	 */
  	if(is_new = ison(headers[number]->status, NEW))
  	  clearit(headers[number]->status, NEW);
! 	copy_message("", fd, FALSE, FALSE, TRUE, FALSE, FALSE);
  	if(is_new)
  	  setit(headers[number]->status, NEW);
  	current = save_current;
--- 227,233 ----
  	 */
  	if(is_new = ison(headers[number]->status, NEW))
  	  clearit(headers[number]->status, NEW);
!       copy_message("", fd, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE);
  	if(is_new)
  	  setit(headers[number]->status, NEW);
  	current = save_current;
diff -cbr orig/src/file_util.c new/src/file_util.c
*** orig/src/file_util.c	Sat Oct 16 18:43:46 1993
--- new/src/file_util.c	Fri Mar 20 23:41:52 1992
***************
*** 35,47 ****
  #endif
  
  #include <signal.h>
- #include <errno.h>
  
  #ifdef BSD
  # include <sys/wait.h>
  #endif
  
  extern int errno;		/* system error number */
  
  char *error_name(), *error_description(), *strcpy(), *getlogin();
  long  fsize();
--- 35,48 ----
  #endif
  
  #include <signal.h>
  
  #ifdef BSD
  # include <sys/wait.h>
  #endif
  
+ #ifndef OS2
  extern int errno;		/* system error number */
+ #endif
  
  char *error_name(), *error_description(), *strcpy(), *getlogin();
  long  fsize();
***************
*** 57,63 ****
  	**/
  
  	int ok = 1;
- 	extern int errno;	/* system error number! */
  	struct stat buffer;
  
  	if (stat(name, &buffer) != 0)
--- 58,63 ----
***************
*** 86,91 ****
--- 86,95 ----
  
  	int the_stat = 0, pid, w;
  	struct stat stat_buf;
+ 
+ #ifdef OS2
+         the_stat = (access(file, mode) == 0) ? 0 : (errno == 0) ? 1 : errno;
+ #else
  	void _exit(), exit();
  #if defined(BSD) && !defined(WEXITSTATUS)
  	union wait status;
***************
*** 134,139 ****
--- 138,145 ----
  
  	signal(SIGINT, istat);
  	signal(SIGQUIT, qstat);
+ #endif
+ 
  	if (the_stat == 0) {
  	  if (stat(file, &stat_buf) == 0) {
  	    w = stat_buf.st_mode & S_IFMT;
***************
*** 159,164 ****
--- 165,183 ----
  
  	FILE *fd;
  	int the_stat = 0, pid, w, preexisted = 0;
+ #ifdef OS2
+ 	errno = 0;
+ 	if (access(file, ACCESS_EXISTS) == 0)
+ 	  preexisted = 1;
+ 	if ((fd = fopen(file, mode)) == NULL)
+ 	  the_stat = errno;
+ 	else {
+ 	  fclose(fd);		/* don't just leave it open! */
+ 	  if(!preexisted)	/* don't leave it if this test created it! */
+ 	    unlink(file);
+ 	  the_stat = 0;
+ 	}
+ #else
  	void _exit(), exit();
  #if defined(BSD) && !defined(WEXITSTATUS)
  	union wait status;
***************
*** 210,215 ****
--- 229,235 ----
  
  	signal(SIGINT, istat);
  	signal(SIGQUIT, qstat);
+ #endif
  
  	return(the_stat);
  }
***************
*** 339,347 ****
  	/* now display the appropriate message if there isn't mail in it */
  	switch(retcode) {
  
! 	case -1:	printf("You have no permission to read %s!\n\r", mfile);
  			break;
! 	case 1:		printf("You have no mail.\n\r");
  			break;
  	case 2:		no_ret(firstline) /* remove newline before using */
  			printf("Your mail is being forwarded to %s.\n\r",
--- 359,367 ----
  	/* now display the appropriate message if there isn't mail in it */
  	switch(retcode) {
  
! 	case -1:	printf("\r\nYou have no permission to read %s!\r\n", mfile);
  			break;
! 	case 1:		printf("\r\nYou have no mail.\r\n");
  			break;
  	case 2:		no_ret(firstline) /* remove newline before using */
  			printf("Your mail is being forwarded to %s.\n\r",
diff -cbr orig/src/fileio.c new/src/fileio.c
*** orig/src/fileio.c	Sat Oct 16 18:43:46 1993
--- new/src/fileio.c	Thu May 04 21:32:02 1995
***************
*** 38,44 ****
--- 38,46 ----
  #undef tolower
  #endif
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *index();
  
***************
*** 48,57 ****
  	     remote,
  	     update_status,
  	     mmdf_head,
! 	     remail)
  char *prefix;
  FILE *dest_file;
! int  remove_header, remote, update_status, mmdf_head, remail;
  {
  	/** Copy current message to destination file, with optional 'prefix'
  	    as the prefix for each line.  If remove_header is true, it will
--- 50,60 ----
  	     remote,
  	     update_status,
  	     mmdf_head,
!            remail,
!            decrypt)
  char *prefix;
  FILE *dest_file;
! int  remove_header, remote, update_status, mmdf_head, remail, decrypt;
  {
  	/** Copy current message to destination file, with optional 'prefix'
  	    as the prefix for each line.  If remove_header is true, it will
***************
*** 68,79 ****
  	    line at the end of the headers.  It never copies an existing one.
  	**/
  
!     char buffer[SLEN];
      register struct header_rec *current_header = headers[current-1];
      register int  lines, front_line, next_front,
  		  in_header = 1, first_line = TRUE, ignoring = FALSE;
      int	end_header = 0;
      int sender_added = 0;
  
        /** get to the first line of the message desired **/
  
--- 71,86 ----
  	    line at the end of the headers.  It never copies an existing one.
  	**/
  
!     char buffer[LONG_STRING];
      register struct header_rec *current_header = headers[current-1];
      register int  lines, front_line, next_front,
  		  in_header = 1, first_line = TRUE, ignoring = FALSE;
      int	end_header = 0;
      int sender_added = 0;
+     FILE *cryptfile;
+     char cfilename[SLEN], dfilename[SLEN], basefilename[SLEN];
+     char ans;
+     int  tlines;
  
        /** get to the first line of the message desired **/
  
***************
*** 100,108 ****
      next_front = TRUE;
  
      while (lines) {
!       if (fgets(buffer, SLEN, mailfile) == NULL)
          break;
  
        front_line = next_front;
  
        if(buffer[strlen(buffer)-1] == '\n') {
--- 107,116 ----
      next_front = TRUE;
  
      while (lines) {
!       if (fgets(buffer, sizeof(buffer), mailfile) == NULL)
          break;
  
+       fixline(buffer);
        front_line = next_front;
  
        if(buffer[strlen(buffer)-1] == '\n') {
***************
*** 233,238 ****
--- 233,239 ----
  	  }
  #else
  	  if (first_word(buffer, "From ")) {
+ 	    if (strcmp(sendmail, mailer) != 0)
  	    if (fprintf(dest_file, "%s%s remote from %s\n",
  		    prefix, buffer, hostname) == EOF) {
  		Write_to_screen("\n\rWrite in copy_message failed\n\r", 0);
***************
*** 258,263 ****
--- 266,272 ----
  	else { /* forwarding */
  
  	  if (first_word(buffer, "Received:"   ) ||
+ 	      first_word(buffer, "From "       ) ||
  	      first_word(buffer, ">From"       ) ||
  	      first_word(buffer, "Status:"     ) ||
  	      first_word(buffer, "Return-Path:"))
***************
*** 278,283 ****
--- 287,375 ----
        }
        else { /* not in header */
          /* Process checks that occur after the header area */
+ 
+ 	/***  Check to see if text is a PGP message  ***/
+ 
+ 	/*  if buffer starts with "-----BEGIN PGP MESSAGE-----"
+ 	       AND decrypt = TRUE
+ 	      divert rest of message to cryptfile
+ 	      decrypt cryptfile file.
+ 	      if success, copy decrypted file into dest_file, then set
+ 			  lines = 0 to stop copying from mailfile.
+ 	      else just continue
+ 	      continue
+ 	*/
+ 
+ 	if( first_word(buffer, "-----BEGIN PGP MESSAGE-----")
+ 	   && decrypt ) {
+ 	  PutLine1(LINES-1,0,"Message encrypted with PGP. Do you wish to decrypt? (y/n) y%c", BACKSPACE);
+ 	  fflush(stdout);
+ 	  ans = ReadCh();
+ 	  if( tolower(ans) != 'n' ) {
+ 	    Write_to_screen("Yes.",0);
+ 	    sprintf(basefilename,"%s%d", temp_dir, getpid());
+ 	    strcpy(cfilename,basefilename);
+ 	    strcpy(dfilename,basefilename);
+ 	    strcat(cfilename,".asc");
+ 	    strcat(dfilename,".txt");
+ 
+ 	    if ((cryptfile = fopen(cfilename,"wt")) == NULL) {
+ 	      if(batch_only)
+ 		printf("Could not create file %s (%s).\n", cfilename, error_name(errno));
+ 	      else
+ 		error2("Could not create file %s (%s).", cfilename, error_name(errno));
+ 	    }
+ 	    else {
+ 
+ 	      chown(cfilename, userid, groupid);
+ 
+ 	      tlines = lines;
+ 	      fputs(buffer,cryptfile);
+ 	      while( tlines )  {
+ 		if(fgets(buffer, sizeof(buffer), mailfile) == NULL)
+ 		  break;
+ 		fixline(buffer);
+ 		fputs(buffer,cryptfile);
+ 		tlines--;
+ 	      }
+ 	      fclose(cryptfile);
+ 
+ 	      sprintf(buffer, "pgp %s -o %s", cfilename, dfilename);
+ 	      puts("\r\n");
+ 	      if( !system_call(buffer, SH, FALSE, FALSE) ) {
+ 		fputs("[pgp-encrypt]\n", dest_file);
+ 		if ((cryptfile = fopen(dfilename, "rt")) != NULL)
+ 		  while( !feof(cryptfile) ) {
+ 		    if( fgets(buffer, sizeof(buffer), cryptfile) != NULL )
+ 		      if (strlen(buffer) >= 6 && strncmp(buffer, "[pgp-", 5) == 0
+ 			  && strncmp(buffer + strlen(buffer) - 2, "]\n", 2) == 0)
+ 			/* skip */;
+ 		      else
+ 			fprintf(dest_file, "%s%s", prefix, buffer);
+ 		  }
+ 	      }
+ 	      else {
+ 		printf("Error while decrypting.  Copying message as-is.\n\r");
+ 		cryptfile = fopen(cfilename, "rt");
+ 		while( !feof(cryptfile) ) {
+ 		  if (fgets(buffer, sizeof(buffer), cryptfile) != NULL)
+ 		    fprintf(dest_file, "%s%s", prefix, buffer);
+ 		}
+ 	      }
+ 	      lines = 0;
+ 	      fclose(cryptfile);
+ 	      if( !access(cfilename,0) )
+ 		if( remove(cfilename) )
+ 		  printf("Could not delete file %s (%s).\n\r", cfilename, error_name(errno));
+ 	      if( !access(dfilename,0) )
+ 		if( remove(dfilename) )
+ 		  printf("Could not delete file %s (%s).\n\r", dfilename, error_name(errno));
+ 	    }
+ 	  }
+ 	  else
+ 	    Write_to_screen("No.",0);
+ 
+ 	} /*  end check for PGP  */
  
  #ifndef MMDF
  	if(first_word(buffer, "From ") && (real_from(buffer, NULL))) {
diff -cbr orig/src/forms.c new/src/forms.c
*** orig/src/forms.c	Sat Oct 16 18:43:48 1993
--- new/src/forms.c	Sun Mar 15 14:19:14 1992
***************
*** 49,55 ****
--- 49,57 ----
  #include "headers.h"
  #include <errno.h>
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *strcat(), *strcpy();
  
***************
*** 103,109 ****
  	  return(-1);
  	}
  
! 	sprintf(newfname, "%s%s%d", temp_dir, temp_form_file, getpid());
  
  	if ((newform = fopen(newfname, "w")) == NULL) {
  	  error("Couldn't open newform file for form output!");
--- 105,111 ----
  	  return(-1);
  	}
  
! 	sprintf(newfname, "%s%d%s", temp_dir, getpid(), temp_form_file);
  
  	if ((newform = fopen(newfname, "w")) == NULL) {
  	  error("Couldn't open newform file for form output!");
***************
*** 136,149 ****
  	    error2("Error %s unlinking file %s.", error_name(errno), filename);
  	    return(-1);
  	  }
! 	  if (link(newfname, filename)) {
! 	    error3("Error %s linking %s to %s.", error_name(errno), 
  		    newfname, filename);
  	    return(-1);
  	  }
  	}
! 
! 	if (unlink(newfname)) {
  	  error2("Error %s unlinking file %s.", error_name(errno), newfname);
  	  return(-1);
  	}
--- 138,150 ----
  	    error2("Error %s unlinking file %s.", error_name(errno), filename);
  	    return(-1);
  	  }
! 	  if (rename(newfname, filename)) {
! 	    error3("Error %s renaming %s to %s.", error_name(errno),
  		    newfname, filename);
  	    return(-1);
  	  }
  	}
!         else if (unlink(newfname)) {
  	  error2("Error %s unlinking file %s.", error_name(errno), newfname);
  	  return(-1);
  	}
diff -cbr orig/src/in_utils.c new/src/in_utils.c
*** orig/src/in_utils.c	Sat Oct 16 18:43:48 1993
--- new/src/in_utils.c	Tue Aug 04 21:45:24 1992
***************
*** 32,40 ****
  #  undef tolower
  #endif
  
  extern int errno;		/* system error number */
- 
  unsigned alarm();
  
  #define isstopchar(c)		(c == ' ' || c == '\t' || c == '/')
  #define isslash(c)		(c == '/')
--- 32,41 ----
  #  undef tolower
  #endif
  
+ #ifndef OS2
  extern int errno;		/* system error number */
  unsigned alarm();
+ #endif
  
  #define isstopchar(c)		(c == ' ' || c == '\t' || c == '/')
  #define isslash(c)		(c == '/')
***************
*** 479,485 ****
  
  	if (timeout > 0) {
  	  alarm((unsigned) timeout);
! #ifdef	BSD
  	  if (setjmp(GetPromptBuf)) {
  	    InGetPrompt = 0;
  	    ch = NO_OP_COMMAND;
--- 480,486 ----
  
  	if (timeout > 0) {
  	  alarm((unsigned) timeout);
! #if defined(BSD) || defined(OS2)
  	  if (setjmp(GetPromptBuf)) {
  	    InGetPrompt = 0;
  	    ch = NO_OP_COMMAND;
diff -cbr orig/src/init.c new/src/init.c
*** orig/src/init.c	Sat Oct 16 18:43:48 1993
--- new/src/init.c	Sun Aug 22 12:34:08 1993
***************
*** 80,86 ****
--- 80,88 ----
  #undef tolower
  #endif
  
+ #ifndef OS2
  extern int errno;		/* system error number on failure */
+ #endif
  extern char version_buff[];
  
  char *error_name(), *error_description();
***************
*** 188,215 ****
  	  if ((i = InitScreen()) < 0) {
  	    if (i == -1) {
  	      printf(
! "Sorry, but you must specify what type of terminal you're on if you want to\n");
  	      printf(
! "run the \"elm\" program. (You need your environment variable \"TERM\" set.)\n"
  		     );
  	      dprint(1,(debugfile,"No $TERM variable in environment!\n"));
  	    }
  	    else if (i == -2) {
  	      printf(
! "You need a cursor-addressable terminal to run \"elm\" and I can't find any\n");
  	      printf(
! "kind of termcap entry for \"%s\" - check your \"TERM\" setting...\n",
  		   getenv("TERM"));
  	      dprint(1,
  		(debugfile,"$TERM variable is an unknown terminal type!\n"));
  	    } else {
! 	      printf("Failed trying to initialize your terminal entry: unknown return code %d\n", i);
! 	      dprint(1, (debugfile, "Initscreen returned unknown code: %d\n",
  		  i));
  	    }
  	    Raw(OFF);
  	    exit(1);	/* all the errors share this exit statement */
  	  }
  	}
  
  	if (debug < 5) {	/* otherwise let the system trap 'em! */
--- 190,222 ----
  	  if ((i = InitScreen()) < 0) {
  	    if (i == -1) {
  	      printf(
! "Sorry, but you must specify what type of terminal you're on if you want to\r\n");
  	      printf(
! "run the \"elm\" program. (You need your environment variable \"TERM\" set.)\r\n"
  		     );
  	      dprint(1,(debugfile,"No $TERM variable in environment!\n"));
  	    }
  	    else if (i == -2) {
  	      printf(
! "You need a cursor-addressable terminal to run \"elm\" and I can't find any\r\n");
  	      printf(
! "kind of termcap entry for \"%s\" - check your \"TERM\" setting...\r\n",
  		   getenv("TERM"));
+ 	      printf(
+ "Or check your TERMCAP setting or termcap database file.\r\n");
  	      dprint(1,
  		(debugfile,"$TERM variable is an unknown terminal type!\n"));
  	    } else {
! 	      printf("Failed trying to initialize your terminal entry: unknown return code %d\r\n", i);
! 	      dprint(1, (debugfile, "Initscreen returned unknown code: %d\r\n",
  		  i));
  	    }
  	    Raw(OFF);
  	    exit(1);	/* all the errors share this exit statement */
  	  }
+           EndBold();
+           EndHalfbright();
+           EndInverse();
  	}
  
  	if (debug < 5) {	/* otherwise let the system trap 'em! */
***************
*** 217,225 ****
  	  signal(SIGTERM, term_signal); 	/* Terminate signal         */
  	  signal(SIGILL,  ill_signal);		/* Illegal instruction      */
  	  signal(SIGFPE,  fpe_signal);		/* Floating point exception */
  	  signal(SIGBUS,  bus_signal);		/* Bus error  		    */
- 	  signal(SIGSEGV, segv_signal);		/* Segmentation Violation   */
  	  signal(SIGHUP,  hup_signal);		/* HangUp (line dropped)    */
  	}
  	else {
  	  dprint(3,(debugfile,
--- 224,234 ----
  	  signal(SIGTERM, term_signal); 	/* Terminate signal         */
  	  signal(SIGILL,  ill_signal);		/* Illegal instruction      */
  	  signal(SIGFPE,  fpe_signal);		/* Floating point exception */
+ #ifndef OS2
  	  signal(SIGBUS,  bus_signal);		/* Bus error  		    */
  	  signal(SIGHUP,  hup_signal);		/* HangUp (line dropped)    */
+ #endif
+ 	  signal(SIGSEGV, segv_signal);		/* Segmentation Violation   */
  	}
  	else {
  	  dprint(3,(debugfile,
***************
*** 233,239 ****
--- 242,250 ----
  #else
  	signal(SIGALRM, alarm_signal);		/* Process Timer Alarm      */
  #endif
+ #ifndef OS2
  	signal(SIGPIPE, pipe_signal);		/* Illegal Pipe Operation   */
+ #endif
  #ifdef SIGTSTP
  	signal(SIGTSTP, sig_user_stop);		/* Suspend signal from tty  */
  	signal(SIGCONT, sig_return_from_user_stop);	/* Continue Process */
***************
*** 295,307 ****
  	  }
  	}
  
  	/* Determine the default mail file name.
  	 *
  	 * First look for an environment variable MAIL, then
  	 * use then mailhome if it is not found
  	 */
  	if ((cp = getenv("MAIL")) == NULL)
! 		sprintf(defaultfile, "%s%s", mailhome, username);
  	    else
  		strcpy(defaultfile, cp);
  
--- 306,329 ----
  	  }
  	}
  
+ #ifdef OS2
+ 	getfromdomain(hostfromname, sizeof(hostfromname));
+ #else
+ 	strcpy(hostfromname, hostfullname);
+ #endif
+ 
  	/* Determine the default mail file name.
  	 *
  	 * First look for an environment variable MAIL, then
  	 * use then mailhome if it is not found
  	 */
  	if ((cp = getenv("MAIL")) == NULL)
! #ifdef OS2
! 	    if (maildir)
! 		sprintf(defaultfile, "%s%s/newmail%s", mailhome, username, mailext);
! 	    else
! #endif
! 		sprintf(defaultfile, "%s%s%s", mailhome, username, mailext);
  	else
  		strcpy(defaultfile, cp);
  
***************
*** 352,361 ****
--- 374,385 ----
  
  	/** fix the shell if needed **/
  
+ #ifndef OS2
  	if (shell[0] != '/') {
  	   sprintf(buffer, "/bin/%s", shell);
  	   strcpy(shell, buffer);
  	}
+ #endif
  
  	if (! mail_only && ! check_only) {
  
diff -cbr orig/src/leavembox.c new/src/leavembox.c
*** orig/src/leavembox.c	Sat Oct 16 18:43:50 1993
--- new/src/leavembox.c	Sun Aug 22 09:19:46 1993
***************
*** 51,56 ****
--- 51,57 ----
  **/
  
  #include "headers.h"
+ #include <string.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #ifdef LOCK_BY_FLOCK
***************
*** 84,90 ****
--- 85,93 ----
  # endif /* NOUTIMBUF */
  #endif /* BSD */
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *error_description(), *strcpy(), *rindex();
  unsigned short getegid();
***************
*** 425,431 ****
  	    if(headers[i]->exit_disposition == STORE) {
  	      current = i+1;
  	      dprint(2, (debugfile, "#%d, ", current));
! 	      copy_message("", temp, FALSE, FALSE, TRUE, FALSE, FALSE);
  	    }
  	  }
  	  fclose(temp);
--- 428,434 ----
  	    if(headers[i]->exit_disposition == STORE) {
  	      current = i+1;
  	      dprint(2, (debugfile, "#%d, ", current));
!             copy_message("", temp, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE);
  	    }
  	  }
  	  fclose(temp);
***************
*** 437,443 ****
  	 * temp file, then remove original and copy whole temp file over.
  	 */
  	if (to_keep > 0) {
! 	  sprintf(temp_keep_file, "%s%s%d", temp_dir, temp_file, getpid());
  	  if ((errno = can_open(temp_keep_file, "w"))) {
  	    error1(
  "Permission to create temp file %s for writing denied! Leaving folder intact.",
--- 440,446 ----
  	 * temp file, then remove original and copy whole temp file over.
  	 */
  	if (to_keep > 0) {
! 	  sprintf(temp_keep_file, "%s%d%s", temp_dir, getpid(), temp_file);
  	  if ((errno = can_open(temp_keep_file, "w"))) {
  	    error1(
  "Permission to create temp file %s for writing denied! Leaving folder intact.",
***************
*** 469,475 ****
  	    if(headers[i]->exit_disposition == KEEP) {
  	      current = i+1;
  	      dprint(2, (debugfile, "#%d, ", current));
! 	      copy_message("", temp, FALSE, FALSE, TRUE, FALSE, FALSE);
  	    }
  	  }
  	  if ( fclose(temp) == EOF ) {
--- 472,478 ----
  	    if(headers[i]->exit_disposition == KEEP) {
  	      current = i+1;
  	      dprint(2, (debugfile, "#%d, ", current));
!             copy_message("", temp, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE);
  	    }
  	  }
  	  if ( fclose(temp) == EOF ) {
***************
*** 486,491 ****
--- 489,495 ----
  	   * folder and we aren't keeping empty non-spool folders,
  	   * simply remove the old original folder and that's it!
  	   */
+           fclose(mailfile);
  	  (void)unlink(cur_folder);
  #ifdef SIGTSTP
  	  signal(SIGTSTP, oldstop);
***************
*** 534,539 ****
--- 538,544 ----
  	    need_to_copy = TRUE;
  
  	  if(!need_to_copy) {
+             fclose(mailfile);
  	    unlink(cur_folder);
  	    if (link(temp_keep_file, cur_folder) != 0) {
  	      if(errno == EXDEV || errno == EEXIST) {
***************
*** 651,663 ****
  	    get_folder_type()), and put it in the static area lock_name.
  	    Return lock_name for informational purposes.
  	 **/
  
  #ifdef XENIX
  	/* lock is /tmp/[basename of file_to_lock].mlk */
  	sprintf(lock_name, "/tmp/%.10s.mlk", rindex(file_to_lock, '/')+1);
  #else
  	/* lock is [file_to_lock].lock */
! 	sprintf(lock_name, "%s.lock", file_to_lock);
  #endif
  	return(lock_name);
  }
--- 656,675 ----
  	    get_folder_type()), and put it in the static area lock_name.
  	    Return lock_name for informational purposes.
  	 **/
+ 	char *ptr;
  
  #ifdef XENIX
  	/* lock is /tmp/[basename of file_to_lock].mlk */
  	sprintf(lock_name, "/tmp/%.10s.mlk", rindex(file_to_lock, '/')+1);
  #else
  	/* lock is [file_to_lock].lock */
! 	strcpy(lock_name, file_to_lock);
! #ifdef OS2
! 	if ( (ptr = strrchr(lock_name, '.')) != NULL
! 	     && strcmp(ptr, mailext) == 0 )
! 	  *ptr = 0;
! #endif
! 	strcat(lock_name, ".lck");
  #endif
  	return(lock_name);
  }
***************
*** 730,736 ****
        do {
  
  	errno = 0;
! 	if((create_fd=open(lock_name,O_WRONLY | O_CREAT | O_EXCL,0444)) != -1)
  	  break;
  	else {
  	  if(errno != EEXIST) {
--- 742,748 ----
        do {
  
  	errno = 0;
! 	if((create_fd=open(lock_name,O_WRONLY | O_CREAT | O_EXCL,0666)) != -1)
  	  break;
  	else {
  	  if(errno != EEXIST) {
***************
*** 767,773 ****
        } while (create_iteration++ < MAX_ATTEMPTS);
        clear_error();
  
!       if(errno != 0) {
  
  	/* we weren't able to create the lock file */
  
--- 779,785 ----
        } while (create_iteration++ < MAX_ATTEMPTS);
        clear_error();
  
!       if(errno != 0 && errno != ENOENT) {
  
  	/* we weren't able to create the lock file */
  
***************
*** 796,802 ****
  	}
  
  	/* we've removed the bad lock, let's try to assert lock once more */
! 	if((create_fd=open(lock_name,O_WRONLY | O_CREAT | O_EXCL,0444)) == -1){
  
  	  /* still can't lock it - just give up */
  	  dprint(1, (debugfile,
--- 808,814 ----
  	}
  
  	/* we've removed the bad lock, let's try to assert lock once more */
! 	if((create_fd=open(lock_name,O_WRONLY | O_CREAT | O_EXCL,0666)) == -1){
  
  	  /* still can't lock it - just give up */
  	  dprint(1, (debugfile,
diff -cbr orig/src/mailmsg1.c new/src/mailmsg1.c
*** orig/src/mailmsg1.c	Sat Oct 16 18:43:50 1993
--- new/src/mailmsg1.c	Thu Sep 16 22:17:42 1993
***************
*** 107,112 ****
--- 107,121 ----
  	if (is_a_response && replying)
  	  generate_reply_to(current-1);
  
+ #ifdef OS2
+ 	/* Reply-To: from UUPC.RC (see os2util.c), from Frank Behrens */
+ 	if (strlen(_reply_to) > 0)
+         {
+ 	   strcpy(reply_to, _reply_to);
+ 	   dprint(4, (debugfile, "Add default Reply-To: %s\n", _reply_to));
+ 	}
+ #endif
+ 
  	/* and mail that puppy outta here! */
  
  	return(mail(copy_msg, edit_message, form_letter));
diff -cbr orig/src/mailmsg2.c new/src/mailmsg2.c
*** orig/src/mailmsg2.c	Sat Oct 16 18:43:52 1993
--- new/src/mailmsg2.c	Fri Apr 22 21:14:06 1994
***************
*** 68,74 ****
--- 68,76 ----
  #undef toupper
  #endif
  
+ #ifndef OS2
  extern int errno;
+ #endif
  extern char version_buff[];
  
  char *error_name(), *error_description(), *strip_parens();
***************
*** 111,117 ****
  	**/
  
  	FILE *reply, *real_reply; /* second is post-input buffer */
! 	char *whole_msg_file, *tempnam();
  	char filename[SLEN], fname[SLEN], copy_file[SLEN],
               very_long_buffer[VERY_LONG_STRING], mailerflags[NLEN];
  	int ch, sys_status;
--- 113,119 ----
  	**/
  
  	FILE *reply, *real_reply; /* second is post-input buffer */
! 	char *whole_msg_file = NULL, *tempnam();
  	char filename[SLEN], fname[SLEN], copy_file[SLEN],
               very_long_buffer[VERY_LONG_STRING], mailerflags[NLEN];
  	int ch, sys_status;
***************
*** 119,124 ****
--- 121,127 ----
  	int      already_has_text = FALSE;		/* we need an ADDRESS */
  	int	 signature_done = FALSE;
  	int	 need_redraw = 0;
+ 	int      resent = forwarding && !edit_message;
  
  	static int cancelled_msg = 0;
  
***************
*** 129,135 ****
  
  	/** first generate the temporary filename **/
  
! 	sprintf(filename,"%s%s%d", temp_dir, temp_file, getpid());
  
  	/** if possible, let's try to recall the last message? **/
  
--- 132,138 ----
  
  	/** first generate the temporary filename **/
  
! 	sprintf(filename,"%s%d%s", temp_dir, getpid(), temp_file);
  
  	/** if possible, let's try to recall the last message? **/
  
***************
*** 162,168 ****
  	}
  
  	if (copy_msg == FORM) {
! 	  sprintf(fname, "%s%s%d", temp_dir, temp_form_file, getpid());
  	  fclose(reply);	/* we can't retransmit a form! */
  	  if (access(fname,ACCESS_EXISTS) != 0) {
  	    if(batch_only)
--- 165,171 ----
  	}
  
  	if (copy_msg == FORM) {
! 	  sprintf(fname, "%s%d%s", temp_dir, getpid(), temp_form_file);
  	  fclose(reply);	/* we can't retransmit a form! */
  	  if (access(fname,ACCESS_EXISTS) != 0) {
  	    if(batch_only)
***************
*** 176,194 ****
  	  rename(fname, filename);
  	}
  	else if (copy_msg && ! retransmit) {  /* if retransmit we have it! */
! 	  if (attribution[0]) {
  	    fprintf(reply, attribution, headers[current-1]->from);
  	    fputc('\n', reply);
  	  }
- 	  else if (forwarding) {
- 	    fputs("Forwarded message:\n", reply);
- 	  }
  	  if (edit_message) {
! 	    copy_message(prefixchars, reply, noheader,FALSE,FALSE,TRUE,FALSE);
  	    already_has_text = TRUE;	/* we just added it, right? */
  	  }
  	  else
! 	    copy_message("", reply, noheader, FALSE, FALSE, TRUE, FALSE);
  	}
  
          /* append signature now if we are going to use an external editor */
--- 179,198 ----
  	  rename(fname, filename);
  	}
  	else if (copy_msg && ! retransmit) {  /* if retransmit we have it! */
! 	  if (forwarding) {
! 	    if (edit_message)
! 	      fputs("Forwarded message:\n", reply);
! 	  }
! 	  else if (attribution[0]) {
  	    fprintf(reply, attribution, headers[current-1]->from);
  	    fputc('\n', reply);
  	  }
  	  if (edit_message) {
!           copy_message(prefixchars, reply, noheader,FALSE,FALSE,TRUE,FALSE,TRUE);
  	    already_has_text = TRUE;	/* we just added it, right? */
  	  }
  	  else
!           copy_message("", reply, noheader, FALSE, FALSE, TRUE, FALSE, FALSE);
  	}
  
          /* append signature now if we are going to use an external editor */
***************
*** 197,203 ****
          if (already_has_text ||
             (strcmp(editor,"builtin") != 0 && strcmp(editor,"none") != 0)) {
  	     signature_done = TRUE;
!              if (!retransmit && copy_msg != FORM)
  	       already_has_text |= append_sig(reply);
  	}
  
--- 201,208 ----
          if (already_has_text ||
             (strcmp(editor,"builtin") != 0 && strcmp(editor,"none") != 0)) {
  	     signature_done = TRUE;
!              if (!(forwarding && !edit_message) &&
!                  !retransmit && copy_msg != FORM)
  	       already_has_text |= append_sig(reply);
  	}
  
***************
*** 262,267 ****
--- 267,276 ----
  	      return(need_redraw);
  	    }
  	    
+ 	    if (ch == 's' && 
+ 		perhaps_pgp_encode(filename) == -1)
+ 	      ch = ' ';
+ 
  	  } while (ch != 's');
  
  	  if (form == YES)
***************
*** 298,310 ****
  
  	/** grab a copy if the user so desires... **/
  
! 	if (*copy_file) /* i.e. if copy_file contains a name */
  	  save_copy(expanded_to, expanded_cc, expanded_bcc,
  	       filename, copy_file, form);
  
  	/** write all header information into whole_msg_file **/
  
! 	if((whole_msg_file=tempnam(temp_dir, "snd.")) == NULL) {
  	  dprint(1, (debugfile, "couldn't make temp file nam! (mail)\n"));
  	  if(batch_only)
  	    printf("Sorry - couldn't make temp file name!\n");
--- 307,319 ----
  
  	/** grab a copy if the user so desires... **/
  
! 	if (*copy_file && !no_save) /* i.e. if copy_file contains a name */
  	  save_copy(expanded_to, expanded_cc, expanded_bcc,
  	       filename, copy_file, form);
  
  	/** write all header information into whole_msg_file **/
  
! 	if((whole_msg_file=tempnam(temp_dir, "snd")) == NULL) {
  	  dprint(1, (debugfile, "couldn't make temp file nam! (mail)\n"));
  	  if(batch_only)
  	    printf("Sorry - couldn't make temp file name!\n");
***************
*** 324,345 ****
  		  expanded_to, expanded_cc, expanded_bcc, subject));
  
  	if ((real_reply=
! 	   write_header_info(whole_msg_file, expanded_to,
! 	     expanded_cc, expanded_bcc, form == YES, FALSE)) == NULL) {
  
  	  /** IT FAILED!!  MEIN GOTT!  Use a dumb mailer instead! **/
  
  	  dprint(3, (debugfile, "** write_header failed: %s\n",
  		 error_name(errno)));
  
! 	  if (cc[0] != '\0')  		/* copies! */
! 	    sprintf(expanded_to,"%s %s", expanded_to, expanded_cc);
  
  	  quote_args(very_long_buffer, strip_parens(strip_commas(expanded_to)));
  	  strcpy(expanded_to, very_long_buffer);
  
! 	  sprintf(very_long_buffer, "( (%s -s \"%s\" %s ; %s %s) & ) < %s",
! 		  mailx, subject, expanded_to, remove_cmd, filename, filename);
  
  	  if(batch_only)
  	    printf("Message sent using dumb mailer %s.\n", mailx);
--- 333,356 ----
  		  expanded_to, expanded_cc, expanded_bcc, subject));
  
  	if ((real_reply=
! 	   write_header_info(whole_msg_file, expanded_to, expanded_cc, 
!              expanded_bcc, form == YES, FALSE, resent)) == NULL) {
  
  	  /** IT FAILED!!  MEIN GOTT!  Use a dumb mailer instead! **/
  
  	  dprint(3, (debugfile, "** write_header failed: %s\n",
  		 error_name(errno)));
  
! 	  if (cc[0] != '\0') {  		/* copies! */
! 	    strcat(expanded_to, " ");
! 	    strcat(expanded_to, expanded_cc);
! 	  }
  
  	  quote_args(very_long_buffer, strip_parens(strip_commas(expanded_to)));
  	  strcpy(expanded_to, very_long_buffer);
  
! 	  sprintf(very_long_buffer, "%s -f %s -s \"%s\" %s",
! 		  mailx, filename, subject, expanded_to);
  
  	  if(batch_only)
  	    printf("Message sent using dumb mailer %s.\n", mailx);
***************
*** 359,366 ****
  
  	  fclose(real_reply);
  
! 	  if (cc[0] != '\0')  				         /* copies! */
! 	    sprintf(expanded_to,"%s %s", expanded_to, expanded_cc);
  
  	  if (bcc[0] != '\0') {
  	    strcat(expanded_to, " ");
--- 370,379 ----
  
  	  fclose(real_reply);
  
! 	  if (cc[0] != '\0') {		         /* copies! */
! 	    strcat(expanded_to, " ");
! 	    strcat(expanded_to, expanded_cc);
! 	  }
  
  	  if (bcc[0] != '\0') {
  	    strcat(expanded_to, " ");
***************
*** 369,403 ****
  
  	  remove_hostbang(expanded_to);
  
! 	  if (strcmp(sendmail, mailer) == 0
! #ifdef SITE_HIDING
! 	      && ! is_a_hidden_user(username))
! #else
! 	     					)
! #endif
! 
! 	    strcpy(mailerflags, (sendmail_verbose ? smflagsv : smflags));
! 	  else if (strcmp(submitmail, mailer) == 0)
! 	    strcpy(mailerflags, submitflags);
! 	  else
! 	    mailerflags[0] ='\0';
! 
! 	  if (strcmp(submitmail, mailer) == 0)
! 	    strcpy(expanded_to, " ");
! 	  else {
! 	    quote_args(very_long_buffer, strip_parens(strip_commas(expanded_to)));
! 	    strcpy(expanded_to, very_long_buffer);
  	  }
- 
- 	  sprintf(very_long_buffer,"( (%s %s %s ; %s %s) & ) < %s", 
- 		mailer, mailerflags, expanded_to,
- 		remove_cmd, whole_msg_file, whole_msg_file);
  	}
  
  	fclose(reply);
  
  	if(batch_only)
! 	  printf("Sending mail...\n");
  	else {
  	  PutLine0(LINES,0,"Sending mail...");
  	  CleartoEOLN();
--- 382,410 ----
  
  	  remove_hostbang(expanded_to);
  
+ 	  sprintf(very_long_buffer,"sndfilt %s %s@%s %s",
+ 		  whole_msg_file, username, hostfromname, 
+ 		  strip_parens(strip_commas(expanded_to)));
+ 	  system_call(very_long_buffer, SH, FALSE, FALSE);
+ 
! 	  if (strcmp(sendmail, mailer) == 0)
! 	  {
! 	    sprintf(very_long_buffer,"sndmail %s -af %s -f %s@%s %s >nul 2>&1",
! 		    background ? "-bg" : "",
! 		    whole_msg_file, username, hostfromname, 
! 		    strip_parens(strip_commas(expanded_to)));
! 	  }
! 	  else
! 	  {
! 	    sprintf(very_long_buffer,"%s -f %s %s 2>nul",
! 		    mailer, whole_msg_file, submitflags);
  	  }
  	}
  
  	fclose(reply);
  
  	if(batch_only)
! 	  printf("Sending mail...\r\n");
  	else {
  	  PutLine0(LINES,0,"Sending mail...");
  	  CleartoEOLN();
***************
*** 416,422 ****
  	} else {
  		/* Success case: */
  		if(batch_only)
! 		  printf("Mail sent!\n");
  		else if(mail_only)
  		  error("Mail sent!");
  		else
--- 418,424 ----
  	} else {
  		/* Success case: */
  		if(batch_only)
! 		  printf("Mail sent!\r\n");
  		else if(mail_only)
  		  error("Mail sent!");
  		else
***************
*** 430,437 ****
  	 * with root privelges. The best we can do is not let this
  	 * file just hang after we're finished with it.
  	 */
  	(void)unlink(filename);
! 
  	return(need_redraw);
  }
  
--- 432,441 ----
  	 * with root privelges. The best we can do is not let this
  	 * file just hang after we're finished with it.
  	 */
+ 	if (!background) /* but only if not using sendmail in background mode */
+ 	  (void)unlink(whole_msg_file);
  	(void)unlink(filename);
!         free(whole_msg_file);
  	return(need_redraw);
  }
  
***************
*** 565,576 ****
  	    } else if (*form_letter == MAYBE)  {
  	       strcpy(buffer, "Choose e)dit msg, m)ake form, ");
  	    } else {
! 	       strcpy(buffer, "Choose e)dit message, ");
  	    }
  #ifdef ALLOW_SUBSHELL
  	    strcat(buffer, "!)shell, ");
  #endif
! 	    strcat(buffer, "h)eaders, c)opy file, s)end, or f)orget.");
  	    Centerline(LINES-1, buffer);
  	  }
  
--- 569,580 ----
  	    } else if (*form_letter == MAYBE)  {
  	       strcpy(buffer, "Choose e)dit msg, m)ake form, ");
  	    } else {
!              strcpy(buffer, "Choose e)dit msg, ");
  	    }
  #ifdef ALLOW_SUBSHELL
  	    strcat(buffer, "!)shell, ");
  #endif
!           strcat(buffer, "h)drs, c)opy file, s)end, f)orget");
  	    Centerline(LINES-1, buffer);
  	  }
  
***************
*** 668,676 ****
  }
  
  FILE *
! write_header_info(filename, long_to, long_cc, long_bcc, form, copy)
  char *filename, *long_to, *long_cc, *long_bcc;
! int   form, copy;
  {
  	/** Try to open filedesc as the specified filename.  If we can,
  	    then write all the headers into the file.  The routine returns
--- 672,680 ----
  }
  
  FILE *
! write_header_info(filename, long_to, long_cc, long_bcc, form, copy, resend)
  char *filename, *long_to, *long_cc, *long_bcc;
! int   form, copy, resend;
  {
  	/** Try to open filedesc as the specified filename.  If we can,
  	    then write all the headers into the file.  The routine returns
***************
*** 684,689 ****
--- 688,694 ----
  	long time(), thetime;
  	char *ctime();
  	static FILE *filedesc;		/* our friendly file descriptor  */
+ 	char *resent = resend ? "Resent-" : "";  /* forwarding ? */
  
  #ifdef SITE_HIDING
  	char  buffer[SLEN];
***************
*** 750,762 ****
  	    of headers is irrelevant).  Gahhhhh....
  	**/
  
! 	fprintf(filedesc, "Subject: %s\n", subject);
! 
! 	  fprintf(filedesc, "To: %s\n", format_long(long_to, strlen("To:")));
! 
! 	fprintf(filedesc,"Date: %s\n", get_arpa_date());
  
  #ifndef DONT_ADD_FROM
  #ifdef MMDF
  	is_submit_mailer = (strcmp(submitmail,mailer) == 0);
  #endif /* MMDF */
--- 755,764 ----
  	    of headers is irrelevant).  Gahhhhh....
  	**/
  
! 	fprintf(filedesc,"%sDate: %s\n", resent, get_arpa_date());
  
  #ifndef DONT_ADD_FROM
+ 	fputs(resent, filedesc);
  #ifdef MMDF
  	is_submit_mailer = (strcmp(submitmail,mailer) == 0);
  #endif /* MMDF */
***************
*** 775,789 ****
  # else
  #  ifdef  INTERNET
  #   ifdef  USE_DOMAIN
! #    ifdef MMDF
  	if (is_submit_mailer)
  	  fprintf(filedesc,"From: %s <%s>\n", full_username, username);
  	else
  #    endif /* MMDF */
  	  fprintf(filedesc,"From: %s <%s@%s>\n", full_username,
! 		username, hostfullname);
  #   else
! #    ifdef MMDF
  	if (is_submit_mailer)
  	  fprintf(filedesc,"From: %s <%s>\n", full_username, username);
  	else
--- 777,791 ----
  # else
  #  ifdef  INTERNET
  #   ifdef  USE_DOMAIN
! #    ifdef _MMDF
  	if (is_submit_mailer)
  	  fprintf(filedesc,"From: %s <%s>\n", full_username, username);
  	else
  #    endif /* MMDF */
  	  fprintf(filedesc,"From: %s <%s@%s>\n", full_username,
! 		username, hostfromname);
  #   else
! #    ifdef _MMDF
  	if (is_submit_mailer)
  	  fprintf(filedesc,"From: %s <%s>\n", full_username, username);
  	else
***************
*** 803,813 ****
  # endif
  #endif
  
  	if (cc[0] != '\0')
! 	    fprintf(filedesc, "Cc: %s\n", format_long(long_cc, strlen("Cc: ")));
  
! 	if (copy && (bcc[0] != '\0'))
! 	    fprintf(filedesc, "Bcc: %s\n", format_long(long_bcc, strlen("Bcc: ")));
  
  	if (strlen(action) > 0)
  	    fprintf(filedesc, "Action: %s\n", action);
--- 805,820 ----
  # endif
  #endif
  
+ 	fprintf(filedesc, "%sSubject: %s\n", resent, subject);
+ 
+ 	fprintf(filedesc, "%sTo: %s\n", resent, format_long(long_to, strlen("To:")));
+ 
  	if (cc[0] != '\0')
! 	    fprintf(filedesc, "%sCc: %s\n", resent, format_long(long_cc, strlen("Cc: ")));
  
! 	if ((copy || stricmp(sendmail, mailer) != 0) &&
! 	    (bcc[0] != '\0'))
! 	    fprintf(filedesc, "%sBcc: %s\n", resent, format_long(long_bcc, strlen("Bcc: ")));
  
  	if (strlen(action) > 0)
  	    fprintf(filedesc, "Action: %s\n", action);
***************
*** 819,825 ****
  	    fprintf(filedesc, "Expires: %s\n", expires);
  
  	if (strlen(reply_to) > 0)
! 	    fprintf(filedesc, "Reply-To: %s\n", reply_to);
  
  	if (strlen(in_reply_to) > 0)
  	    fprintf(filedesc, "In-Reply-To: %s\n", in_reply_to);
--- 826,832 ----
  	    fprintf(filedesc, "Expires: %s\n", expires);
  
  	if (strlen(reply_to) > 0)
! 	    fprintf(filedesc, "%sReply-To: %s\n", resent, reply_to);
  
  	if (strlen(in_reply_to) > 0)
  	    fprintf(filedesc, "In-Reply-To: %s\n", in_reply_to);
***************
*** 833,841 ****
  	  fprintf(filedesc, "Content-Type: mailform\n");
  
  #ifndef NO_XHEADER
! 	fprintf(filedesc, "X-Mailer: ELM [version %s]\n", version_buff);
  #endif /* !NO_XHEADER */
  
   	  putc('\n', filedesc);
  
  	return((FILE *) filedesc);
--- 840,849 ----
  	  fprintf(filedesc, "Content-Type: mailform\n");
  
  #ifndef NO_XHEADER
! 	fprintf(filedesc, "X-Mailer: ELM [version %s] for OS/2\n", version_buff);
  #endif /* !NO_XHEADER */
  
+         if (!resend)
   	  putc('\n', filedesc);
  
  	return((FILE *) filedesc);
***************
*** 901,907 ****
  		emergency_exit();
  	    }
  	}
! #ifdef MMDF
  	if (copy) fputs(MSG_SEPERATOR, dest);
  #else
  	if (copy) fputs("\n", dest);	/* ensure a blank line at the end */
--- 909,915 ----
  		emergency_exit();
  	    }
  	}
! #ifdef _MMDF
  	if (copy) fputs(MSG_SEPERATOR, dest);
  #else
  	if (copy) fputs("\n", dest);	/* ensure a blank line at the end */
***************
*** 997,1003 ****
--- 1005,1016 ----
              if (sig[0]) {  /* if there is a signature file */
  	      if (sig_dashes) /* dashes are optional */
  	        fprintf(file, "\n-- \n");  /* News 2.11 compatibility? */
+ #ifdef OS2
+ 	      if (sig[0] != '/' && sig[0] != '\\' &&
+ 		  (!isalpha(sig[0]) || sig[1] != ':'))
+ #else
  	      if (sig[0] != '/')
+ #endif
  	        sprintf(filename2, "%s/%s", home, sig);
  	      else
  	        strcpy(filename2, sig);
***************
*** 1009,1012 ****
--- 1022,1135 ----
  
  return FALSE;
  
+ }
+ 
+ perhaps_pgp_encode(filename)
+ char *filename;
+ {
+   char buffer[VERY_LONG_STRING];
+   FILE *msg;
+   int encrypt = 0;
+ 
+   if ((msg = fopen(filename, "r")) == NULL)
+     return -1;
+ 
+   while (fgets(buffer, sizeof(buffer), msg) != NULL)
+     if (strncmp(buffer, "[pgp-encrypt]\n", 14) == 0) {
+       encrypt = 1;
+       strcpy(buffer, strip_parens(strip_commas(expanded_to)));
+       if (expanded_cc[0]) {
+ 	strcat(buffer, " ");
+ 	strcat(buffer, strip_parens(strip_commas(expanded_cc)));
+       }
+       if (expanded_bcc[0]) {
+ 	strcat(buffer, " ");
+ 	strcat(buffer, strip_parens(strip_commas(expanded_bcc)));
+       }
+       strcat(buffer, " ");
+       strcat(buffer, username); /* add sender id too! */
+       strcat(buffer, "@");
+       strcat(buffer, hostname);
+       break;
+     }
+     else if (strncmp(buffer, "[pgp-sign]\n", 11) == 0) {
+       sign = 1;
+       break;
+     }
+     else if (strncmp(buffer, "[pgp-encrypt ", 13) == 0 &&
+ 	     strncmp(buffer + strlen(buffer) - 2, "]\n", 2) == 0) {
+       strcpy(buffer, buffer + 13);
+       buffer[strlen(buffer) - 2] = 0;
+       encrypt = 1;
+       break;
+     }
+   fclose(msg);
+ 
+   if (encrypt)
+     return pgp_encrypt(filename, buffer);
+ 
+   if (sign)
+     return pgp_sign(filename);
+ 
+   return 0;
+ }
+ 
+ pgp_encrypt(filename, to)
+ char *filename, *to;
+ {
+   char  buffer[SLEN];
+   char  pgpfn[SLEN];
+   int   dotpos = 0;
+ 
+   sprintf(buffer, "pgp -seaw %s %s", filename, to);
+   puts("\r\n\n");
+ 
+   if (system_call(buffer, SH, FALSE, FALSE) == 0) {
+ 
+     do { ++dotpos; } while (filename[dotpos] != '.');
+     strncpy(pgpfn, filename, dotpos);
+     strcpy(pgpfn + dotpos, ".asc");
+ 
+     if(rename(pgpfn,filename)) {
+       printf("Error with renaming %s to %s in pgp_encrypt! (%s)\n",
+ 	     pgpfn, filename, error_name(errno));
+       return(-1);
+     }
+ 
+     return(0);
+   }
+   else {			/* something went wrong. Bad password or user spec */
+     printf("Error while encrypting. Try again.");
+     return(-1);
+   }
+ }
+ 
+ pgp_sign(filename)
+ char *filename;
+ {
+   char  buffer[SLEN];
+   char  pgpfn[SLEN];
+   int   dotpos = 0;
+ 
+   sprintf(buffer, "pgp -sta +clearsig=on %s", filename);
+   puts("\r\n\n");
+ 
+   if (system_call(buffer, SH, FALSE, FALSE) == 0) {
+ 
+     do { ++dotpos; } while (filename[dotpos] != '.');
+     strncpy(pgpfn, filename, dotpos);
+     strcpy(pgpfn + dotpos, ".asc");
+ 
+     if(unlink(filename) || rename(pgpfn,filename)) {
+       printf("Error with renaming %s to %s in pgp_sign! (%s)\n",
+ 	     pgpfn, filename, error_name(errno));
+       return(-1);
+     }
+ 
+     return(0);
+   }
+   else {			/* something went wrong. Bad password or user spec */
+     printf("Error while signing. Try again.");
+     return(-1);
+   }
  }
diff -cbr orig/src/Makefile new/src/Makefile
*** orig/src/Makefile	Sat Oct 16 18:43:52 1993
--- new/src/Makefile	Fri Apr 22 20:06:06 1994
***************
*** 1,19 ****
  #
! # Makefile for the ELM mail program for OS/2
  #
  
! gcc:
  	$(MAKE) all CC="gcc -O -Zomf -Zmtd" O=".obj" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm32.def"
  
! gccdebug:
  	$(MAKE) all CC="gcc -g" O=".o" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm32.def"
! 
! msc:
! 	$(MAKE) all CC="cl -nologo -AL -Gs -Ocegt" O=".obj" \
! 	CFLAGS="-W1 -Zep1 -Gt16 -D__STDC__ -G2 -J" \
! 	LFLAGS="-Lp" LIBS="..\os2\elm16.def -link /noe /packc /packd"
  
  # Variables
  
--- 1,14 ----
  #
! # Makefile for the Elm mail program for OS/2
  #
  
! release:
  	$(MAKE) all CC="gcc -O -Zomf -Zmtd" O=".obj" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm.def"
  
! debug:
  	$(MAKE) all CC="gcc -g" O=".o" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm.def"
  
  # Variables
  
***************
*** 26,32 ****
  
  # Lists
  
! OS2_OBJ		= alarm$O getopt$O termcap$O os2util$O
  CRYPT_OBJ	= crypt$O crypt_util$O
  
  ELM_OBJ		= $(OS2_OBJ) $(CRYPT_OBJ) \
--- 21,27 ----
  
  # Lists
  
! OS2_OBJ		= alarm$O getopt$O termcap$O os2util$O movemail$O
  CRYPT_OBJ	= crypt$O crypt_util$O
  
  ELM_OBJ		= $(OS2_OBJ) $(CRYPT_OBJ) \
***************
*** 141,146 ****
--- 136,143 ----
  		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/termcap.c
  os2util$O:	$(OS2DIR)/os2util.c
  		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/os2util.c
+ movemail$O:	$(OS2DIR)/movemail.c
+ 		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/movemail.c
  
  crypt$O:	$(CRYPTDIR)/crypt.c
  		$(CC) $(CFLAGS) $(DEFINES) -c $(CRYPTDIR)/crypt.c
diff -cbr orig/src/mkhdrs.c new/src/mkhdrs.c
*** orig/src/mkhdrs.c	Sat Oct 16 18:43:52 1993
--- new/src/mkhdrs.c	Sun Oct 10 17:22:28 1993
***************
*** 46,52 ****
  	    tail_of(headers[msg]->from, buffer, 0);
  	  else
  	    strcpy(buffer, headers[msg]->from);
! 	  sprintf(in_reply_to, "%s; from \"%s\" at %s %s, %s %s",
                    headers[msg]->messageid[0] == '\0'? "<no.id>":
  		  headers[msg]->messageid,
  		  buffer,
--- 46,52 ----
  	    tail_of(headers[msg]->from, buffer, 0);
  	  else
  	    strcpy(buffer, headers[msg]->from);
! 	  sprintf(in_reply_to, "%s from \"%s\" at %s %s %s %s",
                    headers[msg]->messageid[0] == '\0'? "<no.id>":
  		  headers[msg]->messageid,
  		  buffer,
***************
*** 110,116 ****
  	  command[j++] = buffer[i];
  	command[j] = '\0';
  
! 	sprintf(fname,"%s%s%d", temp_dir, temp_print, getpid());
  
  	sprintf(command_buffer, "%s > %s", command, fname);
  
--- 110,116 ----
  	  command[j++] = buffer[i];
  	command[j] = '\0';
  
! 	sprintf(fname,"%s%d%s", temp_dir, getpid(), temp_print);
  
  	sprintf(command_buffer, "%s > %s", command, fname);
  
diff -cbr orig/src/newmbox.c new/src/newmbox.c
*** orig/src/newmbox.c	Sat Oct 16 18:43:54 1993
--- new/src/newmbox.c	Sun Oct 10 17:23:42 1993
***************
*** 62,71 ****
  #  include <sys/time.h>
  #endif
  
  extern int errno;
  
  char *error_name(), *error_description();
! char *malloc(), *realloc(), *strcpy(), *strncpy(), *rindex(), *index();
  unsigned long sleep();
  void rewind();
  void exit();
--- 62,77 ----
  #  include <sys/time.h>
  #endif
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *error_description();
! char *malloc(), *realloc();
! #ifndef __GNUC__
! char *alloca();
! #endif
! char *strcpy(), *strncpy(), *rindex(), *index();
  unsigned long sleep();
  void rewind();
  void exit();
***************
*** 96,101 ****
--- 102,115 ----
  	int err;
  	char new_tempfile[SLEN];
  
+ #ifdef OS2
+ 	char *new_file2 = (char *) alloca(SLEN);
+ 	_fullpath(new_file2, new_file, SLEN);
+ 	strlwr(new_file2);
+ 	unixpath(new_file2);
+ #define new_file new_file2
+ #endif
+ 
  	/* determine type of new mailfile and calculate temp file name */
  	if((new_folder_type = get_folder_type(new_file)) == SPOOL)
  	  mk_temp_mail_fn(new_tempfile, new_file);
***************
*** 124,129 ****
--- 138,146 ----
  	  }
  	}
  
+ 	if (mailfile != NULL)
+ 	  (void) fclose(mailfile);  /* close it first, to avoid too many open */
+ 
  	/* If we were reading a spool file and we are not just reading
  	 * in the additional new messages to the same file, we need to
  	 * remove the corresponding tempfile.
***************
*** 147,156 ****
  	clear_error();
  	clear_central_message();
  
! 	if (mailfile != NULL)
! 	  (void) fclose(mailfile);  /* close it first, to avoid too many open */
! 
! 	if ((mailfile = fopen(cur_folder,"r")) == NULL)  {
  	  if (errno != ENOENT ) { /* error on anything but file not exist */
  	    err = errno;
  	    Write_to_screen("\n\rfail on open in newmbox, open %s failed!!\n\r", 1,
--- 164,170 ----
  	clear_error();
  	clear_central_message();
  
! 	if ((mailfile = fopen(cur_folder,"rb")) == NULL)  {
  	  if (errno != ENOENT ) { /* error on anything but file not exist */
  	    err = errno;
  	    Write_to_screen("\n\rfail on open in newmbox, open %s failed!!\n\r", 1,
***************
*** 200,216 ****
  	if((filename == NULL) || (*filename == '\0'))
  	  return(NO_NAME);
  
  	/* if filename begins with mailhome,
  	 * and there is a slash in filename,
  	 * and there is a filename after it (i.e. last slash is not last char),
  	 * and the last character of mailhome is last slash in filename,
  	 * it's a spool file .
  	 */
! 	if((first_word(filename, mailhome)) &&
! 	  ((last_slash = rindex(filename, '/')) != NULL) &&
! 	  (*(last_slash+1) != '\0') &&
! 	  (filename + strlen(mailhome) - 1 == last_slash))
  	    return(SPOOL);
  	/* if file name == default mailbox, its a spool file also
  	 * even if its not in the spool directory. (SVR4)
  	 */
--- 214,253 ----
  	if((filename == NULL) || (*filename == '\0'))
  	  return(NO_NAME);
  
+ #ifdef OS2
+ #define prefix_path(s, w) (strnicmp(s,w, strlen(w)) == 0)
+ #else
+ #define prefix_path(s, w) first_word(s,w)
+ #endif
+ 
  	/* if filename begins with mailhome,
  	 * and there is a slash in filename,
  	 * and there is a filename after it (i.e. last slash is not last char),
  	 * and the last character of mailhome is last slash in filename,
  	 * it's a spool file .
  	 */
! 	if (prefix_path(filename, mailhome) &&
! 	    (last_slash = rindex(filename, '/')) != NULL &&
! 	    *(last_slash + 1) != '\0') 
! 	{
! #ifdef OS2
! 	  if (!maildir && filename + strlen(mailhome) - 1 == last_slash)
  	    return(SPOOL);
+ 	  if (maildir && strncmp(last_slash, "/newmail", 8) == 0)
+ 	  { 
+ 	    char *previous_slash;
+ 	    *last_slash = 0;
+ 	    previous_slash = rindex(filename, '/');
+             *last_slash = '/';
+ 	    if (previous_slash != NULL &&
+ 		filename + strlen(mailhome) - 1 == previous_slash)
+ 	      return(SPOOL);
+ 	  }
+ #else
+ 	  if (filename + strlen(mailhome) - 1 == last_slash)
+ 	    return(SPOOL);
+ #endif
+         }
  	/* if file name == default mailbox, its a spool file also
  	 * even if its not in the spool directory. (SVR4)
  	 */
***************
*** 228,244 ****
  	    Strangeness may result if it is not!
  	 **/
  
! 	char *cp;
  
! 	sprintf(tempfn, "%s%s", default_temp, temp_mbox);
! 	if((cp = rindex(mbox, '/')) != NULL) {
! 	  cp++;
! 	  if (strcmp(cp, "mbox") == 0 || strcmp(cp, "mailbox") == 0 ||
! 		strcmp(cp, "inbox") == 0 || *cp == '.')
! 	    strcat(tempfn, username);
  	else
! 	    strcat(tempfn, cp);
  	}
  }
  
  int
--- 265,298 ----
  	    Strangeness may result if it is not!
  	 **/
  
! 	char *cp, mb[128];
  
!         strcpy(tempfn, default_temp);
! 	if (tempfn[strlen (tempfn)-1] != '/')
!                 strcat(tempfn, "/");
! 	if((cp = rindex(mbox, '/')) != NULL)
!           strcpy(mb, ++cp);
  	else
! 	  strcpy(mb, mbox);
! #ifdef OS2
! 	if ( (cp = strrchr(mb, '.')) != NULL && strlen(cp) <= 4 )
! 	  *cp = 0;
! #endif
! 	if (strcmp(mb, "mbox") == 0 || strcmp(mb, "mailbox") == 0 ||
! 	    strcmp(mb, "inbox") == 0)
! 	  strcat(tempfn, username);
! #ifdef OS2
! 	else if (strcmp(mb, "newmail") == 0) {
! 	  strcpy(mb, mbox + strlen(mailhome));
! 	  cp = strchr(mb, '/');
! 	  if (strncmp(cp, "/newmail", 8) == 0)
! 	    *cp = 0;
! 	  strcat(tempfn, mb);
  	}
+ #endif
+ 	else
+ 	  strcat(tempfn, mb);
+         strcat(tempfn, temp_mbox);
  }
  
  int
***************
*** 266,271 ****
--- 320,326 ----
  	static int first_read = 0;
  #ifdef MMDF
          int newheader = 0;
+         int fromtoo = 1;
  #endif /* MMDF */
  
  	if (folder_type == SPOOL) {
***************
*** 280,286 ****
  	      error("Ahhhh... I give up.");
  	      silently_exit();	/* leave without tampering with it! */
  	    }
! 	    if ((temp = fopen(cur_tempfolder,"w")) == NULL) {
  	     err = errno;
  	     unlock();	/* remove lock file! */
  	     Raw(OFF);
--- 335,341 ----
  	      error("Ahhhh... I give up.");
  	      silently_exit();	/* leave without tampering with it! */
  	    }
! 	    if ((temp = fopen(cur_tempfolder,"wb")) == NULL) {
  	     err = errno;
  	     unlock();	/* remove lock file! */
  	     Raw(OFF);
***************
*** 299,305 ****
  	   chmod(cur_tempfolder, 0700);	/* shut off file for other people! */
  	 }
  	 else {
! 	   if ((temp = fopen(cur_tempfolder,"a")) == NULL) {
  	     err = errno;
  	     unlock();	/* remove lock file! */
  	     Raw(OFF);
--- 354,360 ----
  	   chmod(cur_tempfolder, 0700);	/* shut off file for other people! */
  	 }
  	 else {
! 	   if ((temp = fopen(cur_tempfolder,"ab")) == NULL) {
  	     err = errno;
  	     unlock();	/* remove lock file! */
  	     Raw(OFF);
***************
*** 333,338 ****
--- 388,402 ----
  	  PutLine0(LINES-2, 0, "Reading message: 0");
  	}
  
+ #ifdef MMDF
+ #ifdef OS2
+ 	if (fgets(buffer, LONG_STRING, mailfile)) {
+           fixline(buffer);
+           fromtoo = !mmdf_strict || strcmp(buffer, MSG_SEPERATOR) != 0;
+         }
+         rewind(mailfile);
+ #endif
+ #endif
  	if (add_new_only) {
  	   if (fseek(mailfile, mailfile_size, 0) == -1) {
  	     err = errno;
***************
*** 373,378 ****
--- 437,443 ----
  		rm_temps_exit();
  	    }
  	  line_bytes = (long) strlen(buffer);
+           fixline(buffer);
  
  	  /* Fix below to increment line count ONLY if we got a full line.
  	   * Input lines longer than the fgets buffer size would
***************
*** 401,407 ****
  	      first_line = FALSE;
  
  #ifdef MMDF
! 	    if (!forwarding_mail && strcmp(buffer, MSG_SEPERATOR) != 0 ) {
  #else
  	    if (! first_word(buffer, "From ") && !forwarding_mail) {
  #endif /* MMDF */
--- 466,473 ----
  	      first_line = FALSE;
  
  #ifdef MMDF
! 	    if (!forwarding_mail && strcmp(buffer, MSG_SEPERATOR) != 0
! 	        && !first_word(buffer, "From ") ) {
  #else
  	    if (! first_word(buffer, "From ") && !forwarding_mail) {
  #endif /* MMDF */
***************
*** 417,424 ****
  	  }
  
  #ifdef MMDF
! 	  if (strcmp(buffer, MSG_SEPERATOR) == 0) {
!             newheader = !newheader;
  #else
  	  if (first_word(buffer,"From ")) {
  #endif /* MMDF */
--- 483,492 ----
  	  }
  
  #ifdef MMDF
! 	  if (strcmp(buffer, MSG_SEPERATOR) == 0
! 	      || !newheader && fromtoo && first_word(buffer,"From ")
!                             && real_from(buffer, NULL)) {
!             newheader = 1; /* !newheader; */
  #else
  	  if (first_word(buffer,"From ")) {
  #endif /* MMDF */
***************
*** 572,577 ****
--- 640,646 ----
  	    }
  	  }
  	  else if (in_header) {
+             newheader = 0;
  #ifdef MMDF
  	    if (first_word(buffer,"From "))
  	      real_from(buffer, current_header);
***************
*** 653,658 ****
--- 722,730 ----
  	      c = index(current_header->mailx_status, '\n');
  	      if (c != NULL)
  		*c = '\0';
+ 	      c = index(current_header->mailx_status, '\r');
+ 	      if (c != NULL)
+ 		*c = '\0';
  	      remove_possible_trailing_spaces(current_header->mailx_status);
  
  	      /* Okay readjust the status. If there's an 'R', message
***************
*** 688,693 ****
--- 760,767 ----
  	  }
  	  if (!in_header && first_word(buffer, START_ENCODE))
  	    current_header->encrypted = 1;
+ 	  if (!in_header && first_word(buffer, "Forwarded "))
+ 	    in_header = 1;
  	  fbytes += (long) line_bytes;
  	}
  
***************
*** 724,730 ****
  	    dprint(0, (debugfile, "newmbox - mbox. != spool mail length"));
  	    rm_temps_exit();
  	  }
! 	  if ((mailfile = fopen(cur_tempfolder,"r")) == NULL) {
  	    err = errno;
  	    MoveCursor(LINES,0);
  	    Raw(OFF);
--- 798,804 ----
  	    dprint(0, (debugfile, "newmbox - mbox. != spool mail length"));
  	    rm_temps_exit();
  	  }
! 	  if ((mailfile = fopen(cur_tempfolder,"rb")) == NULL) {
  	    err = errno;
  	    MoveCursor(LINES,0);
  	    Raw(OFF);
***************
*** 816,821 ****
--- 816,825 ----
  	else
            rewind(mailfile);
  
+ #ifdef OS2
+ 	fcntl(fileno(mailfile), F_SETFD, 1);
+ #endif
+ 
  	/* Sort folder *before* we establish the current message, so that
  	 * the current message is based on the post-sort order.
  	 * Note that we have to set the global variable message_count
diff -cbr orig/src/opt_utils.c new/src/opt_utils.c
*** orig/src/opt_utils.c	Sat Oct 16 18:43:54 1993
--- new/src/opt_utils.c	Sun Mar 29 00:06:14 1992
***************
*** 96,101 ****
--- 96,102 ----
  #endif  /* GETHOSTNAME */
  
  
+ #ifndef OS2
  gethostdomain(hostdom, size)    /* get domain of current host */
  char *hostdom;
  int size;
***************
*** 107,113 ****
  	if (size < 2)
  	  return -1;
  
! 	if ((fp = fopen(hostdomfile, "r")) != 0) {
  	  fgets(buf, sizeof(buf) - 1, fp);
  	  fclose(fp);
  	  if ((p = index(buf, '\n')) != NULL)
--- 108,116 ----
  	if (size < 2)
  	  return -1;
  
!         sprintf(buf, "%s/%s", elmhome, hostdomfile);
! 
! 	if ((fp = fopen(buf, "r")) != 0) {
  	  fgets(buf, sizeof(buf) - 1, fp);
  	  fclose(fp);
  	  if ((p = index(buf, '\n')) != NULL)
***************
*** 125,130 ****
--- 128,134 ----
  
  	return 0;
  }
+ #endif
  
  
  #ifdef NEED_CUSERID
diff -cbr orig/src/options.c new/src/options.c
*** orig/src/options.c	Sat Oct 16 18:43:54 1993
--- new/src/options.c	Sun Mar 15 14:35:20 1992
***************
*** 218,223 ****
--- 218,224 ----
  change_sort(x, y)
  int x,y;
  {
+ 	char *sort_name();
  	/** change the sorting scheme... **/
  	/** return !0 if new sort order, else 0 **/
  
diff -cbr orig/src/pattern.c new/src/pattern.c
*** orig/src/pattern.c	Sat Oct 16 18:43:56 1993
--- new/src/pattern.c	Sat Feb 01 16:02:54 1992
***************
*** 31,37 ****
--- 31,39 ----
  static char pattern[SLEN] = { "" };
  static char alt_pattern[SLEN] = { "" };
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *shift_lower(), *strcpy();
  
***************
*** 218,224 ****
  
  	while (message_number < message_count) {
  
! 	  if (fseek(mailfile, headers[message_number]->offset, 0L) == -1) {
  
  	    dprint(1, (debugfile,
  		"Error: seek %ld bytes into file failed. errno %d (%s)\n",
--- 220,226 ----
  
  	while (message_number < message_count) {
  
! 	  if (fseek(mailfile, headers[message_number]->offset, 0) == -1) {
  
  	    dprint(1, (debugfile,
  		"Error: seek %ld bytes into file failed. errno %d (%s)\n",
diff -cbr orig/src/quit.c new/src/quit.c
*** orig/src/quit.c	Sat Oct 16 18:43:56 1993
--- new/src/quit.c	Sat Feb 01 16:01:12 1992
***************
*** 27,33 ****
--- 27,35 ----
  #include "headers.h"
  #include <errno.h>
  
+ #ifndef OS2
  extern int errno;		/* system error number on failure */
+ #endif
  
  long bytes();
  
diff -cbr orig/src/read_rc.c new/src/read_rc.c
*** orig/src/read_rc.c	Sat Oct 16 18:43:56 1993
--- new/src/read_rc.c	Sun Mar 29 09:56:34 1992
***************
*** 152,158 ****
  
  	strcpy(raw_editor,((cp = getenv("EDITOR")) == NULL)? default_editor:cp);
  
! 	strcpy(temp_dir,((cp = getenv("TMPDIR")) == NULL)? default_temp:cp);
  	if (temp_dir[strlen (temp_dir)-1] != '/')
                  strcat(temp_dir, "/");
  
--- 152,162 ----
  
  	strcpy(raw_editor,((cp = getenv("EDITOR")) == NULL)? default_editor:cp);
  
! #ifdef OS2
!         strcpy(temp_dir, tempdir);
! #else
! 	strcpy(temp_dir,((cp = getenv("TMP")) == NULL)? default_temp:cp);
! #endif
  	if (temp_dir[strlen (temp_dir)-1] != '/')
                  strcat(temp_dir, "/");
  
***************
*** 169,175 ****
  	strcpy(calendar_file, raw_calendar_file);
  
  	/* see if the user has a $HOME/.elm directory */
! 	sprintf(filename, "%s/.elm", home);
  	if (access(filename, 00) == -1) {
  	  if(batch_only)  {
  	    printf("\n\rNotice:\
--- 173,180 ----
  	strcpy(calendar_file, raw_calendar_file);
  
  	/* see if the user has a $HOME/.elm directory */
! 	sprintf(filename, "%s/%s", home, dotelm);
! 
  	if (access(filename, 00) == -1) {
  	  if(batch_only)  {
  	    printf("\n\rNotice:\
***************
*** 200,210 ****
  
  	/* Look for the elmrc file */
  	sprintf(filename,"%s/%s", home, elmrcfile);
  	if ((file = fopen(filename, "r")) == NULL) {
  	  dprint(2,(debugfile,"Warning:User has no \".elm/elmrc\" file\n\n"));
  
  	  /* look for old-style .elmrc file in $HOME */
! 	  sprintf(filename, "%s/.elmrc", home);
  	  if (access(filename, 00) != -1) {
  	    move_old_files_to_new();
  
--- 205,216 ----
  
  	/* Look for the elmrc file */
  	sprintf(filename,"%s/%s", home, elmrcfile);
+ 
  	if ((file = fopen(filename, "r")) == NULL) {
  	  dprint(2,(debugfile,"Warning:User has no \".elm/elmrc\" file\n\n"));
  
  	  /* look for old-style .elmrc file in $HOME */
! 	  sprintf(filename, "%s/%src", home, dotelm);
  	  if (access(filename, 00) != -1) {
  	    move_old_files_to_new();
  
***************
*** 513,518 ****
--- 519,526 ----
  	   * can read them before screen is cleared */
  	  if(errors)
  	    sleep((errors * 2) + 2);
+ 
+           fclose(file);
  	}
  
  	/* see if the user has a folders directory */
diff -cbr orig/src/remail.c new/src/remail.c
*** orig/src/remail.c	Sat Oct 16 18:43:56 1993
--- new/src/remail.c	Fri Apr 22 20:43:28 1994
***************
*** 38,44 ****
--- 38,46 ----
  #include "headers.h"
  #include <errno.h>
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *error_description();
  
***************
*** 52,57 ****
--- 54,60 ----
  	char *filename, buffer[VERY_LONG_STRING], ch;
  	char mailerflags[NLEN];
  	extern char *tempnam();
+         int sys_status;
  
  	entered[0] = '\0';
  
***************
*** 61,67 ****
  
  	display_to(expanded);
  
! 	if((filename=tempnam(temp_dir, "snd.")) == NULL) {
  	  dprint(1, (debugfile, "couldn't make temp file nam! (remail)\n"));
  	  sprintf(buffer, "Sorry - couldn't make file temp file name.");
  	  set_error(buffer);
--- 64,70 ----
  
  	display_to(expanded);
  
! 	if((filename=tempnam(temp_dir, "snd")) == NULL) {
  	  dprint(1, (debugfile, "couldn't make temp file nam! (remail)\n"));
  	  sprintf(buffer, "Sorry - couldn't make file temp file name.");
  	  set_error(buffer);
***************
*** 84,95 ****
  
  	chown (filename, userid, groupid);
  
! #ifdef MMDF
  	if (strcmp(submitmail, mailer) == 0)
  	  do_mmdf_addresses(mailfd, strip_parens(strip_commas(expanded)));
  #endif /* MMDF */
  
! 	copy_message("", mailfd, FALSE, TRUE, FALSE, TRUE, TRUE);
  
  	fclose(mailfd);
  
--- 87,98 ----
  
  	chown (filename, userid, groupid);
  
! #ifdef _MMDF
  	if (strcmp(submitmail, mailer) == 0)
  	  do_mmdf_addresses(mailfd, strip_parens(strip_commas(expanded)));
  #endif /* MMDF */
  
! 	copy_message("", mailfd, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE);
  
  	fclose(mailfd);
  
***************
*** 112,140 ****
  	}
  	Write_to_screen("Yes.", 0);
  
! 	if (strcmp(sendmail, mailer) == 0
! #ifdef SITE_HIDING
! 	    && ! is_a_hidden_user(username))
! #else
! 					 )
! #endif
! 	  strcpy(mailerflags, (sendmail_verbose ? smflagsv : smflags));
! 	else if (strcmp(submitmail, mailer) == 0) {
! 	  strcpy(mailerflags, submitflags_s);
!           strcpy(expanded, " ");
! 	} else
! 	  mailerflags[0] = '\0';
! 
! 	sprintf(buffer,"( (%s %s %s ; %s %s) & ) < %s", 
! 	      mailer, mailerflags, strip_parens(strip_commas(expanded)), 
! 	      remove_cmd, filename, filename);
  
  	PutLine0(LINES,0,"Resending mail...");
! 	system_call(buffer, SH, FALSE, FALSE);
  	        set_error("Mail resent.");
  
  	return(1);
  }
  #ifdef MMDF
  do_mmdf_addresses(dest_file,buffer)
  FILE *dest_file;
--- 115,148 ----
  	}
  	Write_to_screen("Yes.", 0);
  
! 	if (strcmp(sendmail, mailer) == 0)
! 	{
! 	  sprintf(buffer,"sndmail %s -af %s -f %s@%s %s >nul 2>&1", 
! 		  background ? "-bg" : "",
! 		  filename, username, hostfromname, 
! 		  strip_parens(strip_commas(expanded)));
! 	}
! 	else
! 	  sprintf(buffer,"%s -f %s %s 2>nul", 
! 		  mailer, filename, strip_parens(strip_commas(expanded)));
! 	}
  
  	PutLine0(LINES,0,"Resending mail...");
! 
! 	if ( sys_status = system_call(buffer, SH, FALSE, FALSE) ) {
! 		/* problem case: */
! 		sprintf(buffer, "mailer returned error status %d", sys_status);
! 		set_error(buffer);
! 	} else {
  	        set_error("Mail resent.");
+         }
+ 
+ 	if (!background)
+ 	  unlink(filename);
  
  	return(1);
  }
+ 
  #ifdef MMDF
  do_mmdf_addresses(dest_file,buffer)
  FILE *dest_file;
diff -cbr orig/src/reply.c new/src/reply.c
*** orig/src/reply.c	Sat Oct 16 18:43:58 1993
--- new/src/reply.c	Sat Feb 01 16:03:14 1992
***************
*** 30,37 ****
--- 30,39 ----
  #ifndef BSD
  #  include <sys/types.h>
  # ifndef VMS
+ # ifndef OS2
  #  include <sys/utsname.h>
  # endif
+ # endif
  #endif
  
  /** Note that this routine generates automatic header information
***************
*** 41,47 ****
--- 43,51 ----
  
  char *strip_parens(), *get_token();
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *strcat(), *strcpy();
  
***************
*** 390,395 ****
--- 390,410 ----
  	dprint(6, (debugfile,"get_return_name called with (%s, <>, shift=%s)\n",
  		   address, onoff(trans_to_lowercase)));
  
+ 	/* skip leading white space */
+ 	while (whitespace(*address))
+ 	  address++;
+ 
+ 	/* skip possible "" quoted full name and possible opening < */
+ 	if (*address == '"') {
+ 	  for (address++; *address != '"' && *address != 0; address++);
+ 	  if (*address == '"')
+ 	    address++;
+ 	  while (whitespace(*address))
+ 	    address++;
+ 	}
+ 	if (*address == '<')
+ 	  address++;
+ 
  	/* First step - copy address up to a comma, space, or EOLN */
  
  	for (i=0; address[i] != ',' && ! whitespace(address[i]) &&
diff -cbr orig/src/returnadd.c new/src/returnadd.c
*** orig/src/returnadd.c	Sat Oct 16 18:43:58 1993
--- new/src/returnadd.c	Sat May 23 18:45:44 1992
***************
*** 48,54 ****
--- 48,56 ----
  
  char *shift_lower();
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name(), *strcat(), *strcpy();
  
***************
*** 245,251 ****
  	char buf[SLEN], name1[SLEN], name2[SLEN], lastname[SLEN];
  	char hold_return[SLEN], alt_name2[SLEN], buf2[SLEN];
  	int ok = 1, lines, len_buf, len_buf2;
! 	int using_to = FALSE;
  
  	/* now initialize all the char buffers [thanks Keith!] */
  
--- 247,253 ----
  	char buf[SLEN], name1[SLEN], name2[SLEN], lastname[SLEN];
  	char hold_return[SLEN], alt_name2[SLEN], buf2[SLEN];
  	int ok = 1, lines, len_buf, len_buf2;
! 	int using_to = FALSE, in_header = FALSE;
  
  	/* now initialize all the char buffers [thanks Keith!] */
  
***************
*** 275,285 ****
--- 277,289 ----
  	/** okay!  Now we're there!  **/
  
  	lines = headers[msgnum]->lines;
+ 	in_header = TRUE;
  
  	buffer[0] = '\0';
  
  	ok = (int) (fgets(buf2, SLEN, mailfile) != NULL);
  	if (ok) {
+ 	  fixline(buf2);
  	  len_buf2 = strlen(buf2);
  	  if(buf2[len_buf2-1] == '\n') lines--; /* got a full line */
  	}
***************
*** 290,295 ****
--- 294,300 ----
  	  len_buf = strlen(buf);
  	  ok = (int) (fgets(buf2, SLEN, mailfile) != NULL);
  	  if (ok) {
+ 	    fixline(buf2);
  	    len_buf2 = strlen(buf2);
  	    if(buf2[len_buf2-1] == '\n') lines--; /* got a full line */
  	  }
***************
*** 309,314 ****
--- 314,331 ----
  
  /* At this point, "buf" contains the unfolded header line, while "buf2" contains
     the next single line of text from the mail file */
+ 
+ 	  if (in_header) {
+ 	    if (len_buf == 1) /* \n only */
+ 	      in_header = FALSE;
+ 	  }
+ 	  else {
+ 	    if (first_word(buf, "Forwarded "))
+ 	      in_header = TRUE;
+ 	  }
+ 
+ 	  if (!in_header)
+ 	    continue;
  
  	  if (first_word(buf, "From "))
  	    sscanf(buf, "%*s %s", hold_return);
***************
*** 445,451 ****
            ok = (int) (fgets(mybuf, LONG_STRING, mailfile) != NULL);
  	  no_ret(mybuf);	/* remove return character */
  
!           if (first_word(mybuf, "To: ")) {
  	    in_to = TRUE;
  	    strcpy(buffer, (char *) mybuf + strlen("To: "));
            }
--- 445,451 ----
            ok = (int) (fgets(mybuf, LONG_STRING, mailfile) != NULL);
  	  no_ret(mybuf);	/* remove return character */
  
!           if (first_word(mybuf, "To:")) {
  	    in_to = TRUE;
  	    strcpy(buffer, (char *) mybuf + strlen("To: "));
            }
diff -cbr orig/src/save_opts.c new/src/save_opts.c
*** orig/src/save_opts.c	Sat Oct 16 18:43:58 1993
--- new/src/save_opts.c	Wed Apr 01 12:18:02 1992
***************
*** 35,41 ****
--- 35,43 ----
  
  #define absolute(x)		((x) < 0? -(x) : (x))
  
+ #ifndef OS2
  extern  int errno;
+ #endif
  extern char version_buff[];
  
  char *error_name(), *sort_name();
***************
*** 64,70 ****
  	**/
  
  	FILE *newelmrc;
! 	char  oldfname[SLEN], newfname[SLEN];
  
  	sprintf(newfname, "%s/%s", home, elmrcfile);
  	sprintf(oldfname, "%s/%s", home, old_elmrcfile);
--- 66,72 ----
  	**/
  
  	FILE *newelmrc;
! 	char  oldfname[SLEN], newfname[SLEN], inffname[SLEN];
  
  	sprintf(newfname, "%s/%s", home, elmrcfile);
  	sprintf(oldfname, "%s/%s", home, old_elmrcfile);
***************
*** 82,91 ****
  	}
  
  	/** now let's open the datafile if we can... **/
  
! 	if ((elminfo = fopen(ELMRC_INFO, "r")) == NULL) 
  	  error1("Warning: saving without comments! Can't get to %s.",
! 		  ELMRC_INFO);
  
  	/** next, open the new .elm/elmrc file... **/
  
--- 84,94 ----
  	}
  
  	/** now let's open the datafile if we can... **/
+ 	sprintf(inffname,"%s/%s", helphome, elmrc_info);
  
! 	if ((elminfo = fopen(inffname, "r")) == NULL)
  	  error1("Warning: saving without comments! Can't get to %s.",
! 		  inffname);
  
  	/** next, open the new .elm/elmrc file... **/
  
diff -cbr orig/src/savecopy.c new/src/savecopy.c
*** orig/src/savecopy.c	Sat Oct 16 18:44:00 1993
--- new/src/savecopy.c	Tue Sep 28 23:36:40 1993
***************
*** 39,49 ****
  char *ctime();
  
  extern char in_reply_to[SLEN];	/* In-Reply-To: string */
  extern int errno;
  
  char *strcat(), *strcpy();
  unsigned long sleep();
! long  time();
  
  save_copy(to, cc, bcc, filename, copy_file, form)
  char *to, *cc, *bcc, *filename, *copy_file;
--- 39,51 ----
  char *ctime();
  
  extern char in_reply_to[SLEN];	/* In-Reply-To: string */
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *strcat(), *strcpy();
  unsigned long sleep();
! time_t time();
  
  save_copy(to, cc, bcc, filename, copy_file, form)
  char *to, *cc, *bcc, *filename, *copy_file;
***************
*** 129,135 ****
  
  	/* Write header */
  	if ((save = write_header_info(savename, to, cc, bcc,
! 	      form == YES, TRUE)) == NULL)
  	  return(FALSE);
  
  	/* Now add file with message as handed to mailer */
--- 131,137 ----
  
  	/* Write header */
  	if ((save = write_header_info(savename, to, cc, bcc,
! 	      form == YES, TRUE, FALSE)) == NULL)
  	  return(FALSE);
  
  	/* Now add file with message as handed to mailer */
diff -cbr orig/src/showmsg.c new/src/showmsg.c
*** orig/src/showmsg.c	Sat Oct 16 18:44:00 1993
--- new/src/showmsg.c	Wed Nov 17 10:44:46 1993
***************
*** 38,44 ****
--- 38,48 ----
  # undef       tolower
  #endif
  
+ #ifdef OS2
+ # include <sys/wait.h>
+ #else
  extern int errno;
+ #endif
  
  char *error_name(), *strcat(), *strcpy();
  void   _exit();
***************
*** 88,93 ****
--- 90,97 ----
  	    buf_len;				/* line length */
  	struct header_rec *current_header = headers[number-1];
  
+ 	FILE *msgfile = mailfile;
+ 	char clearfile[SLEN];
  
  	lines = current_header->lines;
  
***************
*** 127,132 ****
--- 131,140 ----
  	if(current_header->encrypted)
  	  getkey(OFF);
  
+ 	if (filter)
+ 	  lines += perhaps_pgp_decode(number, clearfile);
+ 	fseek(mailfile, current_header->offset, 0); /* again */
+ 
  	if(builtin=(first_word(pager,"builtin")||first_word(pager,"internal")))
  
  	  start_builtin(lines);
***************
*** 136,141 ****
--- 144,153 ----
  	  /* put terminal out of raw mode so external pager has normal env */
  	  Raw(OFF);
  
+ #ifdef OS2
+           if ( (pipe_wr_fp = popen(pager, "w")) == NULL )
+             return -1;
+ #else
  	  /* create pipe for external pager and fork */
  
  	  if(pipe(pipe_fd) == -1) {
***************
*** 213,218 ****
--- 225,231 ----
  	    Raw(OFF);
  	    return(val);	/* pager may have already touched the screen */
  	  }
+ #endif
  
  	  /* and that's it! */
  	  lines_displayed = 0;
***************
*** 247,253 ****
  	  /* truncate or pad title2 portion on the right
  	   * so that line fits exactly */
  	  padding =
! 	    COLUMNS -
  	    (strlen(title1) + (buf_len=strlen(title2)) + strlen(title3));
  
  	  sprintf(titlebuf, "%s%-*.*s%s\n", title1, buf_len+padding,
--- 260,266 ----
  	  /* truncate or pad title2 portion on the right
  	   * so that line fits exactly */
  	  padding =
! 	    COLUMNS - 1 -
  	    (strlen(title1) + (buf_len=strlen(title2)) + strlen(title3));
  
  	  sprintf(titlebuf, "%s%-*.*s%s\n", title1, buf_len+padding,
***************
*** 356,363 ****
  
  	while (lines > 0 && pipe_abort == FALSE) {
  
! 	    if (fgets(buffer, VERY_LONG_STRING, mailfile) == NULL) {
  	      
  		dprint(1, (debugfile,
  		  "Premature end of file! Lines left = %d msg = %s (show_msg)\n",
  		  lines, number));
--- 369,377 ----
  
  	while (lines > 0 && pipe_abort == FALSE) {
  
! 	    if (fgets(buffer, VERY_LONG_STRING, msgfile) == NULL) {
  	      
+ 	      if (msgfile == mailfile) {
  		dprint(1, (debugfile,
  		  "Premature end of file! Lines left = %d msg = %s (show_msg)\n",
  		  lines, number));
***************
*** 366,371 ****
--- 380,393 ----
  		sleep(2);
  		break;
  	      }
+ 	      else {
+ 		fclose(msgfile);
+ 		unlink(clearfile);
+ 		clearfile[0] = 0;
+ 		msgfile = mailfile;
+ 		continue;
+ 	      }
+ 	    }
  	    if ((buf_len=strlen(buffer)) > 0)  {
  	      if(buffer[buf_len - 1] == '\n') {
  		lines--;
***************
*** 392,397 ****
--- 414,422 ----
                  encode(buffer);
  	        val = show_line(buffer, builtin);
  	      }
+ 	      else if (strlen(buffer) >= 5 && strncmp(buffer, "[pgp-", 5) == 0
+ 			&& buffer[strlen(buffer) - 1] == ']')
+ 		/* skip */ ;
  	      else
  	        val = show_line(buffer, builtin);
  	    }
***************
*** 412,417 ****
--- 437,456 ----
  	    }
  	    else if (form_letter_section == 1 || form_letter_section == 3)
  	      /** skip this stuff - we can't deal with it... **/;
+ 	    else if (strcmp(buffer, "-----BEGIN PGP MESSAGE-----") == 0
+ 		     && filter) 
+ 	    {
+ 	      /* skip PGP block and insert cleartext file for it */
+ 	      do 
+ 	      {
+ 		if (fgets(buffer, VERY_LONG_STRING, msgfile) == NULL)
+ 		  break;
+ 		if ((buf_len=strlen(buffer)) > 0)
+ 		  no_ret(buffer);
+ 	      } while (strcmp(buffer, "-----END PGP MESSAGE-----") != 0);
+ 	      if (strlen(clearfile) > 0)
+ 		msgfile = fopen(clearfile, "r");
+ 	    }
  	    else
  	      val = show_line(buffer, builtin);
  
***************
*** 421,436 ****
--- 460,487 ----
  
          if (cursor_control) transmit_functions(ON);
  
+ 	if (msgfile != mailfile) {
+ 	  fclose(msgfile);
+ 	  unlink(clearfile);
+ 	}
+ 
  	if (!builtin) {
+ #ifdef OS2
+ 	  wait_stat = pclose(pipe_wr_fp);
+ 	  val = WIFEXITED(wait_stat) ? WEXITSTATUS(wait_stat) : 0;
+ #else
  	  fclose(pipe_wr_fp);
  	  while ((wait_ret = wait(&wait_stat)) != fork_ret
  		  && wait_ret!= -1)
  	    ;
+ #endif
  	  /* turn raw on **after** child terminates in case child
  	   * doesn't put us back to cooked mode after we return ourselves
  	   * to raw.
  	   */
  	  Raw(ON);
+ 	  EndBold();
+ 	  ClearScreen();
  	}
  
  	/* If we are to prompt for a user input command and we don't
***************
*** 476,479 ****
--- 526,609 ----
  	if (errno != 0)
  	  dprint(1, (debugfile, "\terror %s hit!\n", error_name(errno)));
  	return(0);
+ }
+ 
+ 
+ perhaps_pgp_decode(number, filename)
+ int number;
+ char *filename;
+ {
+   char buffer[VERY_LONG_STRING], cryptname[SLEN], clearname[SLEN];
+   int lines = headers[number-1] -> lines;
+   int oldlines = 0, pgp = 0, sign = 0;
+   FILE *tempfile;
+ 
+   filename[0] = 0;
+   sprintf(cryptname, "%s%d%s", temp_dir, getpid(), temp_file);
+   sprintf(clearname, "%s%d.msg", temp_dir, getpid());
+       
+   if ((tempfile = fopen(cryptname, "w")) == NULL) 
+   {
+     if(batch_only)
+       printf("Could not create file %s (%s).\n", cryptname, error_name(errno));
+     else
+       error2("Could not create file %s (%s).", cryptname, error_name(errno));
+     return 0;
+   }
+ 
+   while (lines--) 
+   {
+     if (fgets(buffer, VERY_LONG_STRING, mailfile) == NULL)
+       return 0;
+ 
+     no_ret(buffer);
+ 
+     if (pgp)
+       oldlines++;
+ 
+     if (strcmp(buffer, "-----BEGIN PGP MESSAGE-----") == 0)
+       pgp = 1;
+     else if (strcmp(buffer, "-----BEGIN PGP SIGNED MESSAGE-----") == 0)
+       pgp = sign = 1;
+ 
+     if (pgp)
+       fprintf(tempfile, "%s\n", buffer);
+ 
+     if (strcmp(buffer, "-----END PGP MESSAGE-----") == 0)
+       pgp = 0;
+     else if (strcmp(buffer, "-----END PGP SIGNATURE-----") == 0)
+       pgp = 0;
+   }
+ 
+   fclose(tempfile);
+ 
+   if (oldlines == 0)
+   {
+     unlink(cryptname);
+     return 0;
+   }
+ 
+   sprintf(buffer, "pgp -f <%s >%s", cryptname, clearname);
+   os2path(buffer);
+   puts("\r\n");
+ 
+   if (sign)
+     strcpy(clearname, "nul");
+ 
+   if (system_call(buffer, SH, FALSE, FALSE)) 
+   {
+     if (batch_only)
+       printf("Error while decrypting. Try again.\n");
+     else
+       error2("Error while decrypting. Try again.");
+     return 0;
+   }
+ 
+   if (sign)
+   {
+     puts("");
+     PutLine0(LINES,0,"Please Press any key to continue.");
+     (void) ReadCh();
+     return 0;
+   }
+ 
+   if ((tempfile = fopen(clearname, "r")) == NULL) 
+   {
+     if(batch_only)
+       printf("Could not read file %s (%s).\n", clearname, error_name(errno));
+     else
+       error2("Could not read file %s (%s).", clearname, error_name(errno));
+     return 0;
+   }
+ 
+   for (lines = 0; fgets(buffer, VERY_LONG_STRING, tempfile) != NULL; lines++);
+   fclose(tempfile);
+ 
+   strcpy(filename, clearname);
+   return lines - oldlines;
  }
diff -cbr orig/src/signals.c new/src/signals.c
*** orig/src/signals.c	Sat Oct 16 18:44:00 1993
--- new/src/signals.c	Thu Sep 16 23:20:58 1993
***************
*** 94,100 ****
  alarm_signal()
  {
  	/** silently process alarm signal for timeouts... **/
! #ifdef	BSD
  	if (InGetPrompt)
  		longjmp(GetPromptBuf, 1);
  #else
--- 94,104 ----
  alarm_signal()
  {
  	/** silently process alarm signal for timeouts... **/
! #ifdef OS2
! 	signal(SIGALRM, SIG_ACK);
! 	signal(SIGALRM, alarm_signal);
! #endif
! #if defined(BSD) || defined(OS2)
  	if (InGetPrompt)
  		longjmp(GetPromptBuf, 1);
  #else
***************
*** 109,116 ****
  	dprint(2, (debugfile, "*** received SIGPIPE ***\n\n"));
  
  	pipe_abort = TRUE;	/* internal signal ... wheeee!  */
! 
  	signal(SIGPIPE, pipe_signal);
  }
  
  #ifdef SIGTSTP
--- 113,122 ----
  	dprint(2, (debugfile, "*** received SIGPIPE ***\n\n"));
  
  	pipe_abort = TRUE;	/* internal signal ... wheeee!  */
! #ifndef OS2
! 	signal(SIGPIPE, SIG_ACK);
  	signal(SIGPIPE, pipe_signal);
+ #endif
  }
  
  #ifdef SIGTSTP
diff -cbr orig/src/strings.c new/src/strings.c
*** orig/src/strings.c	Sat Oct 16 18:44:02 1993
--- new/src/strings.c	Sun Aug 22 13:25:40 1993
***************
*** 219,224 ****
--- 219,230 ----
  	    found in the output stream...
  	**/
  
+ #ifdef OS2
+ #define MAXLENGTH 1
+ #else
+ #define MAXLENGTH 80
+ #endif
+ 
  	static char ret_buffer[VERY_LONG_STRING];
  	register int iindex = 0, current_length = 0, depth=15, i, len;
  	char     buffer[VERY_LONG_STRING];
***************
*** 234,240 ****
  
  	    /* first, decide what sort of separator we need, if any... */
  
! 	  if (strlen(word) + current_length > 80) {
  	    if (iindex > 0) {
  	      ret_buffer[iindex++] = ',';	/* close 'er up, doctor! */
  	      ret_buffer[iindex++] = '\n';
--- 240,246 ----
  
  	    /* first, decide what sort of separator we need, if any... */
  
! 	  if (strlen(word) + current_length > MAXLENGTH) {
  	    if (iindex > 0) {
  	      ret_buffer[iindex++] = ',';	/* close 'er up, doctor! */
  	      ret_buffer[iindex++] = '\n';
diff -cbr orig/src/syscall.c new/src/syscall.c
*** orig/src/syscall.c	Sat Oct 16 18:44:02 1993
--- new/src/syscall.c	Sun Jan 16 11:31:50 1994
***************
*** 54,59 ****
--- 54,63 ----
  #  include <sys/wait.h>
  #endif
  
+ #ifdef OS2
+ #  include <process.h>
+ #endif
+ 
  char *argv_zero();
  void  _exit();
  
***************
*** 72,82 ****
--- 76,91 ----
  	helpful = (user_level == 0);
  
  	if (helpful)
+ #ifdef OS2
+ 	  PutLine0(LINES-3,COLUMNS-40,"(Enter empty command for a shell.)");
+ #else
  	  PutLine0(LINES-3,COLUMNS-40,"(Use the shell name for a shell.)");
+ #endif
  	PutLine0(LINES-2,0,"Shell command: ");
  	CleartoEOS();
  	command[0] = '\0';
  	(void) optionally_enter(command, LINES-2, 15, FALSE, FALSE);
+ #ifndef OS2
  	if (command[0] == 0) {
  	  if (helpful)
  	    MoveCursor(LINES-3,COLUMNS-40);
***************
*** 85,90 ****
--- 94,100 ----
  	  CleartoEOS();
  	  return 0;
  	}
+ #endif
  
  	MoveCursor(LINES,0);
  	CleartoEOLN();
***************
*** 100,115 ****
  	umask(077);		/* now put it back to private for mail files */
  
  	SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
- 	PutLine0(LINES, 0, "\n\nPress any key to return to ELM: ");
  	Raw(ON);
  	    (void) getchar();
  	if (old_raw == OFF)
  	  Raw(OFF);
  	softkeys_on();
  	if (cursor_control)
  	  transmit_functions(ON);
  
! 	if (ret)
  	  error1("Return code was %d.", ret);
  
  	return 1;
--- 110,127 ----
  	umask(077);		/* now put it back to private for mail files */
  
  	SetXYLocation(0, 40);	/* a location not near the next request, so an absolute is used */
  	Raw(ON);
+ 	if (command[0]) {
+ 	    PutLine0(LINES, 0, "\r\n\r\nPress any key to return to ELM: ");
  	    (void) getchar();
+ 	}
  	if (old_raw == OFF)
  	  Raw(OFF);
  	softkeys_on();
  	if (cursor_control)
  	  transmit_functions(ON);
  
! 	if (ret && command[0])
  	  error1("Return code was %d.", ret);
  
  	return 1;
***************
*** 151,161 ****
--- 163,185 ----
  	register int (*oldstop)(), (*oldstart)();
  # endif
  #endif
+ #ifndef OS2
  	extern int errno;
+ #endif
  
  	sh = (shell_type == USER_SHELL) ? shell : "/bin/sh";
  	dprint(2, (debugfile, "System Call: %s\n\t%s\n", sh, string));
  
+ #ifdef OS2
+         tflush();
+ 
+ 	if ( shell_type != USER_SHELL )
+           if ( (sh = getenv("COMSPEC")) == NULL )
+             if ( (sh = getenv("SHELL")) == NULL )
+               sh = default_shell;
+ 
+         stat = spawnlp(P_WAIT, sh, sh, string[0] ? "/c" : NULL, string, NULL);
+ #else
  	/*
  	 * Note the neat trick with close-on-exec pipes.
  	 * If the child's exec() succeeds, then the pipe read returns zero.
***************
*** 261,266 ****
--- 285,292 ----
  	(void) signal(SIGCONT, oldstart);
  #endif
  
+ #endif  /* OS2 */
+ 
  	return(stat);
  }
  
***************
*** 318,324 ****
  
  	char buffer[SLEN], filename[SLEN], printbuffer[SLEN];
  	char message_list[SLEN];
! 	register int  retcode, to_print;
  
  	if (strlen(printout) == 0) {
  	  error("Don't know how to print - option \"printmail\" undefined!");
--- 344,350 ----
  
  	char buffer[SLEN], filename[SLEN], printbuffer[SLEN];
  	char message_list[SLEN];
! 	register int  retcode, to_print, cnt;
  
  	if (strlen(printout) == 0) {
  	  error("Don't know how to print - option \"printmail\" undefined!");
***************
*** 327,340 ****
  
  	to_print = make_msg_list(message_list);
  
! 	sprintf(filename,"%s%s%d", temp_dir, temp_print, getpid());
  
  	if (in_string(printout, "%s"))
  	  sprintf(printbuffer, printout, filename);
  	else
  	  sprintf(printbuffer, "%s %s", printout, filename);
  
! 	sprintf(buffer,"(%s -p -f %s%s > %s; %s 2>&1) > /dev/null",
  		readmsg,
  		(folder_type == NON_SPOOL ? cur_folder : cur_tempfolder),
  		message_list,
--- 353,367 ----
  
  	to_print = make_msg_list(message_list);
  
! 	sprintf(filename,"%s%d%s", temp_dir, getpid(), temp_print);
! 	os2path(filename);
  
  	if (in_string(printout, "%s"))
  	  sprintf(printbuffer, printout, filename);
  	else
  	  sprintf(printbuffer, "%s %s", printout, filename);
  
! 	sprintf(buffer,"%s -p -f %s %s >%s & %s 1>nul 2>nul",
  		readmsg,
  		(folder_type == NON_SPOOL ? cur_folder : cur_tempfolder),
  		message_list,
***************
*** 398,411 ****
  	    Helpmsg is what should be printed before the listing if not NULL.
  	**/
  
! 	char buffer[SLEN];
  
  	Raw(OFF);
  	ClearScreen();
! 	MoveCursor(LINES, 0);
  	if(helpmsg)
  	  printf(helpmsg);
! 	sprintf(buffer, "dir /w \"%s\"", folders);
  	printf("\n\rContents of your folder directory:\n\r\n\r");
  	system_call(buffer, SH, FALSE, FALSE);
  	while(numlines--)
--- 425,442 ----
  	    Helpmsg is what should be printed before the listing if not NULL.
  	**/
  
!         char buffer[SLEN], foldersbs[SLEN];
  
  	Raw(OFF);
  	ClearScreen();
! 	MoveCursor(0, 0);
  	if(helpmsg)
  	  printf(helpmsg);
! 
!         strcpy(foldersbs,folders);
!         os2path(foldersbs);
!         sprintf(buffer, "dir /w %s", foldersbs);
! 
  	printf("\n\rContents of your folder directory:\n\r\n\r");
  	system_call(buffer, SH, FALSE, FALSE);
  	while(numlines--)
diff -cbr orig/src/utils.c new/src/utils.c
*** orig/src/utils.c	Sat Oct 16 18:44:02 1993
--- new/src/utils.c	Mon Apr 06 16:33:04 1992
***************
*** 36,42 ****
--- 36,44 ----
  
  #include <signal.h>
  
+ #ifndef OS2
  extern int errno;
+ #endif
  
  char *error_name();
  void   exit();
***************
*** 68,83 ****
  
  	char source[SLEN];
  #ifdef MKDIR
! 	sprintf(source, "%s/.elm", home);
  	(void) mkdir(source, 0700);
  #else
  	char com[SLEN];
  
  	/** Some systems don't have a mkdir call - how inconvienient! **/
  
! 	sprintf(com, "mkdir %s/.elm", home);
  	system_call(com, SH, FALSE, FALSE);
! 	sprintf(com, "chmod 700 %s/.elm", home);
  	system_call(com, SH, FALSE, FALSE);
  #endif /* MKDIR */
  
--- 70,85 ----
  
  	char source[SLEN];
  #ifdef MKDIR
! 	sprintf(source, "%s/%s", home, dotelm);
  	(void) mkdir(source, 0700);
  #else
  	char com[SLEN];
  
  	/** Some systems don't have a mkdir call - how inconvienient! **/
  
! 	sprintf(com, "mkdir %s/%s", home, dotelm);
  	system_call(com, SH, FALSE, FALSE);
! 	sprintf(com, "chmod 700 %s/%s", home, dotelm);
  	system_call(com, SH, FALSE, FALSE);
  #endif /* MKDIR */
  
***************
*** 108,121 ****
  	  (void) system_call("newalias", SH, FALSE, FALSE);
  	}
  
! 	sprintf(source, "%s/.elmheaders", home);
  	if (access(source, ACCESS_EXISTS) != -1) {
  	  sprintf(dest,   "%s/%s", home, mailheaders);
  	  printf("\n\rCopying from: %s\n\rCopying to:   %s\n\r", source, dest);
  	  copy(source, dest);
  	}
  
! 	sprintf(source, "%s/.elmrc", home);
  	if (access(source, ACCESS_EXISTS) != -1) {
  	  sprintf(dest,   "%s/%s", home, elmrcfile);
  	  printf("\n\rCopying from: %s\n\rCopying to:   %s\n\r", source, dest);
--- 110,123 ----
  	  (void) system_call("newalias", SH, FALSE, FALSE);
  	}
  
! 	sprintf(source, "%s/%sheaders", home, dotelm);
  	if (access(source, ACCESS_EXISTS) != -1) {
  	  sprintf(dest,   "%s/%s", home, mailheaders);
  	  printf("\n\rCopying from: %s\n\rCopying to:   %s\n\r", source, dest);
  	  copy(source, dest);
  	}
  
! 	sprintf(source, "%s/%src", home, dotelm);
  	if (access(source, ACCESS_EXISTS) != -1) {
  	  sprintf(dest,   "%s/%s", home, elmrcfile);
  	  printf("\n\rCopying from: %s\n\rCopying to:   %s\n\r", source, dest);
***************
*** 142,148 ****
  	if(folder_type == SPOOL) dprint(1, (debugfile,
  	     "     The mailbox lock file: %s\n", mk_lockname(cur_folder)));
  	dprint(1, (debugfile,
! 	     "     The composition file : %s%s%d\n", temp_dir, temp_file, getpid()));
  	dprint(1, (debugfile,
  	     "     The readmsg data file: %s/%s\n", home, readmsg_file));
  
--- 144,150 ----
  	if(folder_type == SPOOL) dprint(1, (debugfile,
  	     "     The mailbox lock file: %s\n", mk_lockname(cur_folder)));
  	dprint(1, (debugfile,
! 	     "     The composition file : %s%d%s\n", temp_dir, getpid(), temp_file));
  	dprint(1, (debugfile,
  	     "     The readmsg data file: %s/%s\n", home, readmsg_file));
  
***************
*** 151,161 ****
  	if (hp_terminal)     softkeys_off();
  
  	if (cursor_control)
! 	  MoveCursor(LINES, 0);
  
  	PutLine0(LINES,0,
  		"\nEmergency exit taken! All temp files intact!\n\n");
  
  	exit(1);
  }
  rm_temps_exit()
--- 153,164 ----
  	if (hp_terminal)     softkeys_off();
  
  	if (cursor_control)
! 	  MoveCursor(LINES-1, 0);
  
  	PutLine0(LINES,0,
  		"\nEmergency exit taken! All temp files intact!\n\n");
  
+         ExitScreen();
  	exit(1);
  }
  rm_temps_exit()
***************
*** 167,184 ****
        Raw(OFF);
        if (cursor_control)  transmit_functions(OFF);
        if (hp_terminal)     softkeys_off();
!       sprintf(buffer,"%s%d",temp_file, getpid());  /* editor buffer */
        (void) unlink(buffer);
        if (folder_type == SPOOL) {
          (void) unlink(cur_tempfolder);
        }
        sprintf(buffer,"%s/%s", home, readmsg_file);  /* readmsg temp */
        (void) unlink(buffer);
        unlock();                               /* remove lock file if any */
        if(!batch_only) {
!         MoveCursor(LINES,0);
          NewLine();
        }
        exit(1);
  }
  
--- 170,190 ----
        Raw(OFF);
        if (cursor_control)  transmit_functions(OFF);
        if (hp_terminal)     softkeys_off();
!       sprintf(buffer,"%d%s", getpid(), temp_file);  /* editor buffer */
        (void) unlink(buffer);
        if (folder_type == SPOOL) {
+         if (mailfile)
+           fclose(mailfile);
          (void) unlink(cur_tempfolder);
        }
        sprintf(buffer,"%s/%s", home, readmsg_file);  /* readmsg temp */
        (void) unlink(buffer);
        unlock();                               /* remove lock file if any */
        if(!batch_only) {
!         MoveCursor(LINES-1,0);
          NewLine();
        }
+       ExitScreen();
        exit(1);
  }
  
***************
*** 196,205 ****
  	if (cursor_control)  transmit_functions(OFF);
  	if (hp_terminal)     softkeys_off();
  
! 	sprintf(buffer,"%s%s%d", temp_dir, temp_file, getpid());  /* editor buffer */
  	(void) unlink(buffer);
  
  	if (folder_type == SPOOL) {
  	  (void) unlink(cur_tempfolder);
  	}
  
--- 202,213 ----
  	if (cursor_control)  transmit_functions(OFF);
  	if (hp_terminal)     softkeys_off();
  
! 	sprintf(buffer,"%s%d%s", temp_dir, getpid(), temp_file);  /* editor buffer */
  	(void) unlink(buffer);
  
  	if (folder_type == SPOOL) {
+           if (mailfile)
+             fclose(mailfile);
  	  (void) unlink(cur_tempfolder);
  	}
  
***************
*** 209,218 ****
  	unlock();				/* remove lock file if any */
  
  	if(!batch_only) {
! 	  MoveCursor(LINES,0);
  	  NewLine();
  	}
  
  	exit(0);
  }
  
--- 217,227 ----
  	unlock();				/* remove lock file if any */
  
  	if(!batch_only) {
! 	  MoveCursor(LINES-1,0);
  	  NewLine();
  	}
  
+ 	ExitScreen();
  	exit(0);
  }
  
***************
*** 230,241 ****
  	if (cursor_control)  transmit_functions(OFF);
  	if (hp_terminal)     softkeys_off();
  
! 	sprintf(buffer,"%s%s%d", temp_dir, temp_file, getpid());  /* editor buffer */
  	(void) unlink(buffer);
  
! 	MoveCursor(LINES,0);
  	NewLine();
  
  	exit(0);
  }
  
--- 239,251 ----
  	if (cursor_control)  transmit_functions(OFF);
  	if (hp_terminal)     softkeys_off();
  
! 	sprintf(buffer,"%s%d%s", temp_dir, getpid(), temp_file);  /* editor buffer */
  	(void) unlink(buffer);
  
! 	MoveCursor(LINES-1,0);
  	NewLine();
  
+ 	ExitScreen();
  	exit(0);
  }
  
***************
*** 256,268 ****
  	if (cursor_control)  transmit_functions(OFF);
  	if (hp_terminal)     softkeys_off();
  
! 	sprintf(buffer,"%s%s%d", temp_dir, temp_file, getpid());  /* editor buffer */
  	(void) unlink(buffer);
  
  	(void) unlink(cur_tempfolder);			/* temp mailbox */
  
! 	MoveCursor(LINES,0);
  	NewLine();
  	exit(0);
  }
  #endif
--- 266,281 ----
  	if (cursor_control)  transmit_functions(OFF);
  	if (hp_terminal)     softkeys_off();
  
! 	sprintf(buffer,"%s%d%s", temp_dir, getpid(), temp_file);  /* editor buffer */
  	(void) unlink(buffer);
  
+         if (mailfile)
+           fclose(mailfile);
  	(void) unlink(cur_tempfolder);			/* temp mailbox */
  
! 	MoveCursor(LINES-1,0);
  	NewLine();
+ 	ExitScreen();
  	exit(0);
  }
  #endif
diff -cbr orig/src/validname.c new/src/validname.c
*** orig/src/validname.c	Sat Oct 16 18:44:04 1993
--- new/src/validname.c	Sat May 23 19:38:18 1992
***************
*** 20,27 ****
   *
   ******************************************************************************/
  
- #include "defs.h"
- 
  #include <stdio.h>
  
  #ifndef NOCHECK_VALIDNAME		 /* Force a return of valid */
--- 20,25 ----
***************
*** 32,37 ****
--- 30,37 ----
  # endif
  #endif
  
+ #include "defs.h"
+ 
  int
  valid_name(name)
  char *name;
***************
*** 53,59 ****
  	if(getpwnam(name) != NULL)
  	  return(TRUE);
  
! 	sprintf(filebuf,"%s/%s", mailhome, name);
  	if (access(filebuf, ACCESS_EXISTS) == 0)
  	  return(TRUE);
  
--- 53,64 ----
  	if(getpwnam(name) != NULL)
  	  return(TRUE);
  
! #ifdef OS2
! 	if (maildir)
! 	    sprintf(filebuf, "%s%s/newmail%s", mailhome, name, mailext);
! 	else
! #endif
! 	sprintf(filebuf,"%s%s%s", mailhome, name, mailext);
  	if (access(filebuf, ACCESS_EXISTS) == 0)
  	  return(TRUE);
  
diff -cbr orig/utils/answer.c new/utils/answer.c
*** orig/utils/answer.c	Sat Oct 16 18:44:04 1993
--- new/utils/answer.c	Sat Mar 28 17:55:48 1992
***************
*** 32,44 ****
  #include <stdio.h>
  #include <fcntl.h>
  #include <ctype.h>
  
  #include "defs.h"			/* ELM system definitions      */
  
  #define  ELM		"elm"		/* where the elm program lives */
  
- #define  answer_temp_file	"/tmp/answer."
- 
  static char ident[] = { WHAT_STRING };
  
  struct alias_rec user_hash_table  [MAX_UALIASES];
--- 32,43 ----
  #include <stdio.h>
  #include <fcntl.h>
  #include <ctype.h>
+ #include <pwd.h>
  
  #include "defs.h"			/* ELM system definitions      */
  
  #define  ELM		"elm"		/* where the elm program lives */
  
  static char ident[] = { WHAT_STRING };
  
  struct alias_rec user_hash_table  [MAX_UALIASES];
***************
*** 55,60 ****
--- 54,60 ----
  	char  name[SLEN], user_name[SLEN];
  	int   msgnum = 0, eof;
  
+         initpaths();
  	read_alias_files();
  
  	while (1) {
***************
*** 64,70 ****
  
  prompt:   printf("\nMessage to: ");
  	  if (fgets(user_name, SLEN, stdin) == NULL) {
! 		putchar('\n');
  		exit(0);
  	  }
  	  if(user_name[0] == '\0')
--- 64,70 ----
  
  prompt:   printf("\nMessage to: ");
  	  if (fgets(user_name, SLEN, stdin) == NULL) {
! 		putc('\n', stdout);
  		exit(0);
  	  }
  	  if(user_name[0] == '\0')
***************
*** 94,100 ****
  	    goto prompt;
  	  }
  
! 	  sprintf(tempfile, "%s%d", answer_temp_file, msgnum++);
  
  	  if ((fd = fopen(tempfile,"w")) == NULL)
  	    exit(printf("** Fatal Error: could not open %s to write\n",
--- 94,100 ----
  	    goto prompt;
  	  }
  
! 	  sprintf(tempfile, "%s%d.ans", tempdir, msgnum++);
  
  	  if ((fd = fopen(tempfile,"w")) == NULL)
  	    exit(printf("** Fatal Error: could not open %s to write\n",
***************
*** 115,124 ****
  	  fclose(fd);
  
  	  sprintf(buffer,
! 	     "((%s -s \"While You Were Out\" %s ; %s %s) & ) < %s > /dev/null",
! 	     ELM, strip_parens(address), remove_cmd, tempfile, tempfile);
  
  	  system(buffer);
  	}
  }
  
--- 115,125 ----
  	  fclose(fd);
  
  	  sprintf(buffer,
! 	     "%s -s \"While You Were Out\" %s <%s >nul",
! 	     ELM, strip_parens(address), tempfile);
  
  	  system(buffer);
+           unlink(tempfile);
  	}
  }
  
***************
*** 164,171 ****
  
  	char fname[SLEN];
  	int  hash;
  
! 	sprintf(fname,  "%s/.elm/aliases.hash", getenv("HOME")); 
  
  	if ((hash = open(fname, O_RDONLY)) == -1)
  	  exit(printf("** Fatal Error: Could not open %s!\n", fname));
--- 165,183 ----
  
  	char fname[SLEN];
  	int  hash;
+         char *getenv();
+         struct passwd *getpwuid();
+         struct passwd *pass;
+         char *homedir, *name;
+ 
+ 	name = getenv("LOGNAME");
+ 	if((pass = getpwnam(name ? name : "unknown")) == NULL) {
+ 	  printf("You have no password entry!\n");
+ 	  exit(1);
+ 	}
+ 	homedir = pass->pw_dir;
  
! 	sprintf(fname,  "%s/%s", homedir, ALIAS_HASH);
  
  	if ((hash = open(fname, O_RDONLY)) == -1)
  	  exit(printf("** Fatal Error: Could not open %s!\n", fname));
***************
*** 173,179 ****
  	read(hash, user_hash_table, sizeof user_hash_table);
  	close(hash);
  
! 	sprintf(fname,  "%s/.elm/aliases.data", getenv("HOME")); 
  
  	if ((user_data = open(fname, O_RDONLY)) == -1)
  	  return;
--- 185,191 ----
  	read(hash, user_hash_table, sizeof user_hash_table);
  	close(hash);
  
! 	sprintf(fname,  "%s/%s", homedir, ALIAS_DATA);
  
  	if ((user_data = open(fname, O_RDONLY)) == -1)
  	  return;
***************
*** 317,330 ****
  	    space = loc + length;
  	    while (buffer[space] != ' ' && space > loc + 50) space--;
  	    for (i=loc;i <= space;i++)
! 	      putchar(buffer[i]);
! 	    putchar('\n');
  	    loc = space;
  	  }
  	  else {
  	    for (i=loc, len = strlen(buffer);i < len;i++)
! 	      putchar(buffer[i]);
! 	    putchar('\n');
  	    loc = len;
  	  }
  	  length = 80;
--- 329,342 ----
  	    space = loc + length;
  	    while (buffer[space] != ' ' && space > loc + 50) space--;
  	    for (i=loc;i <= space;i++)
! 	      putc(buffer[i], stdout);
! 	    putc('\n', stdout);
  	    loc = space;
  	  }
  	  else {
  	    for (i=loc, len = strlen(buffer);i < len;i++)
! 	      putc(buffer[i], stdout);
! 	    putc('\n', stdout);
  	    loc = len;
  	  }
  	  length = 80;
diff -cbr orig/utils/arepdaem.c new/utils/arepdaem.c
*** orig/utils/arepdaem.c	Sat Oct 16 18:44:04 1993
--- new/utils/arepdaem.c	Sun Sep 26 16:28:24 1993
***************
*** 83,97 ****
  
  static char ident[] = { WHAT_STRING };
  
! #define arep_lock_file	"LCK..arep"
! 
! #define autoreply_file	"/etc/autoreply.data"
! 
! #define logfile		"/etc/autoreply.log"	/* first choice   */
! #define logfile2	"/tmp/autoreply.log"	/* second choice  */
  
  #define BEGINNING	0		/* see fseek(3S) for info */
! #define SLEEP_TIME	3600		/* run once an hour       */
  #define MAX_PEOPLE	20		/* max number in program  */
  
  #define EXISTS		00		/* lock file exists??     */
--- 83,95 ----
  
  static char ident[] = { WHAT_STRING };
  
! char     arep_lock_file[SLEN];  /* autoreply lock file  */
! char     autoreply_file[SLEN];  /* autoreply data file  */
! char     logfile[SLEN];         /* first choice   */
! #define logfile2	("/" AUTOREP_LOG)	/* second choice  */
  
  #define BEGINNING	0		/* see fseek(3S) for info */
! #define SLEEP_TIME	1800 /* 3600		/* run once an hour       */
  #define MAX_PEOPLE	20		/* max number in program  */
  
  #define EXISTS		00		/* lock file exists??     */
***************
*** 130,140 ****
--- 128,146 ----
  	int  person, data_changed;
  	time_t time;
  
+         initpaths();
+         sprintf(autoreply_file, "%s/%s", elmhome, AUTOREP_FILE);
+         sprintf(logfile,        "%s/%s", elmhome, AUTOREP_LOG);
+         sprintf(arep_lock_file, "%s/%s", elmhome, AUTOREP_LOCK);
+ 
+ #ifndef OS2
  	if (fork()) exit(0);
+ #endif
  
  	if (! lock())
  	  exit(0);	/* already running! */
  
+ 	signal(SIGINT, term_signal); 	/* Terminate signal         */
  	signal(SIGTERM, term_signal); 	/* Terminate signal         */
  
  /*
***************
*** 143,150 ****
--- 149,158 ----
   *	The idea is to disassociate from the terminal to
   *	prevent signals.
   */
+ #ifndef OS2
  	person = getpid();
  	setpgrp(person, person);
+ #endif
  
  	while (1) {
  
***************
*** 159,164 ****
--- 167,173 ----
  
  	  /* 2. now for each active person... */
  
+ 	  /* move_incoming_mail(); */
  	  data_changed = 0;
  
  	  for (person = 0; person < active; person++) {
***************
*** 210,216 ****
  	if ((file = fopen(autoreply_file,"r")) == NULL) {
  	  log("No-one is using autoreply...");
  	} else {
! 	  while (fscanf(file, "%s %s %dl", username, replyfile, &size) != EOF) {
  	    /* check to see if this person is already in the list */
  	    if ((person = in_list(username)) != -1) {
  	      reply_table[person].in_list = 1;
--- 219,225 ----
  	if ((file = fopen(autoreply_file,"r")) == NULL) {
  	  log("No-one is using autoreply...");
  	} else {
! 	  while (fscanf(file, "%s %s %ld", username, replyfile, &size) != EOF) {
  	    /* check to see if this person is already in the list */
  	    if ((person = in_list(username)) != -1) {
  	      reply_table[person].in_list = 1;
***************
*** 307,313 ****
  
  	log("New mail for %s", reply_table[person].username);
  
!         if ((mailfile = fopen(reply_table[person].mailfile,"r")) == NULL)
             return(log("can't open mailfile for user %s",
  		    reply_table[person].username));
  
--- 316,322 ----
  
  	log("New mail for %s", reply_table[person].username);
  
!         if ((mailfile = fopen(reply_table[person].mailfile,"rb")) == NULL)
             return(log("can't open mailfile for user %s",
  		    reply_table[person].username));
  
***************
*** 347,352 ****
--- 356,363 ----
        if (fgets(buffer, SLEN, file) == NULL)
  	return(-1);
  
+       fixline(buffer);
+ 
        if (first_word(buffer, "From ")) {
  	in_header++;
  	sscanf(buffer, "%*s %s", hold_return);
***************
*** 473,479 ****
  	    is to check to see if new mail has arrived....  **/
  
  	int ok = 1;
- 	extern int errno;	/* system error number! */
  	struct stat buffer;
  
  	if (stat(name, &buffer) != 0)
--- 484,489 ----
***************
*** 495,501 ****
  	    This is to check to see if autoreply has changed....  **/
  
  	int ok = 1;
- 	extern int errno;	/* system error number! */
  	struct stat buffer;
  
  	if (stat(name, &buffer) != 0)
--- 505,510 ----
***************
*** 517,525 ****
  
  	char buffer[VERY_LONG_STRING];
  
! 	sprintf(buffer, "%s/fastmail -f '%s [autoreply]' -s '%s' %s %s",
! 		BIN, reply_table[person].username,
! 	        subject, filename, to);
  
  	system(buffer);
  }
--- 526,533 ----
  
  	char buffer[VERY_LONG_STRING];
  
! 	sprintf(buffer, "fastmail -f \"%s [autoreply]\" -s \"%s\" %s %s",
! 		reply_table[person].username, subject, filename, to);
  
  	system(buffer);
  }
***************
*** 536,542 ****
  	long	  clock;
  #ifndef	_POSIX_SOURCE
  	struct tm *localtime();
! 	long      time();
  #endif
  	char      buffer[SLEN];
  
--- 544,550 ----
  	long	  clock;
  #ifndef	_POSIX_SOURCE
  	struct tm *localtime();
! 	time_t time();
  #endif
  	char      buffer[SLEN];
  
***************
*** 608,616 ****
  	char lock_name[SLEN];		/* name of lock file  */
  	char pid_buffer[SHORT];
  	int pid, create_fd;
- 	extern int errno;	/* system error number! */
  
! 	sprintf(lock_name, "%s/%s", LOCK_DIR, arep_lock_file);
  #ifdef PIDCHECK
        /** first, try to read the lock file, and if possible, check the pid.
  	  If we can validate that the pid is no longer active, then remove
--- 616,623 ----
  	char lock_name[SLEN];		/* name of lock file  */
  	char pid_buffer[SHORT];
  	int pid, create_fd;
  
! 	strcpy(lock_name, arep_lock_file);
  #ifdef PIDCHECK
        /** first, try to read the lock file, and if possible, check the pid.
  	  If we can validate that the pid is no longer active, then remove
***************
*** 655,660 ****
--- 662,668 ----
  {
  	/** remove lock file if it's there! **/
  
+         chmod(arep_lock_file, 0666);
  	(void) unlink(arep_lock_file);
  }
  
diff -cbr orig/utils/autoreply.c new/utils/autoreply.c
*** orig/utils/autoreply.c	Sat Oct 16 18:44:06 1993
--- new/utils/autoreply.c	Sun Mar 29 10:06:00 1992
***************
*** 46,55 ****
  
  static char ident[] = { WHAT_STRING };
  
! #define  tempdir	"/tmp/arep"		/* file prefix          */
! #define  autoreply_file	"/etc/autoreply.data"   /* autoreply data file  */
  
- extern   int errno;				/* system error code    */
  char     username[NLEN];	/* login name of user   */
  
  main(argc, argv)
--- 46,53 ----
  
  static char ident[] = { WHAT_STRING };
  
! char     autoreply_file[SLEN];	/* autoreply data file  */
  
  char     username[NLEN];	/* login name of user   */
  
  main(argc, argv)
***************
*** 63,70 ****
  	struct passwd *getpwuid();
  #endif
  
  	if (argc > 2) {
! 	  printf("Usage: %s <filename>\tto start autoreply,\n", argv[0]);
  	  printf("       %s off\t\tto turn off autoreply\n", argv[0]);
  	  printf("   or  %s    \t\tto check current status\n", argv[0]);
  	  exit(1);
--- 61,71 ----
  	struct passwd *getpwuid();
  #endif
  
+         initpaths();
+         sprintf(autoreply_file, "%s/%s", elmhome, AUTOREP_FILE);
+ 
  	if (argc > 2) {
! 	  printf("\nUsage: %s <filename>\tto start autoreply,\n", argv[0]);
  	  printf("       %s off\t\tto turn off autoreply\n", argv[0]);
  	  printf("   or  %s    \t\tto check current status\n", argv[0]);
  	  exit(1);
***************
*** 86,99 ****
  	  remove_user((argc == 1));
  	else {
  	  strcpy(filename, argv[1]);
  	  if (access(filename,READ_ACCESS) != 0) {
  	    printf("Error: Can't read file '%s'\n", filename);
  	    exit(1);
  	  }
  
- 	  if (filename[0] != '/') /* prefix home directory */
- 	    sprintf(filename,"%s/%s", getenv("HOME"), argv[1]);
- 
  	  add_user(filename);
  	}
  
--- 87,101 ----
  	  remove_user((argc == 1));
  	else {
  	  strcpy(filename, argv[1]);
+ 
+ 	  if (filename[0] != '/') /* prefix home directory */
+ 	    sprintf(filename,"%s/%s", pass->pw_dir, argv[1]);
+ 
  	  if (access(filename,READ_ACCESS) != 0) {
  	    printf("Error: Can't read file '%s'\n", filename);
  	    exit(1);
  	  }
  
  	  add_user(filename);
  	}
  
***************
*** 113,119 ****
  	long  filesize, bytes();
  
  	if (! stat_only) {
! 	  sprintf(tempfile, "%s.%06d", tempdir, getpid());
  
  	  if ((temp = fopen(tempfile, "w")) == NULL) {
  	    printf("Error: couldn't open tempfile '%s'.  Not removed\n",
--- 115,121 ----
  	long  filesize, bytes();
  
  	if (! stat_only) {
! 	  sprintf(tempfile, "%s%d.ar", tempdir, getpid());
  
  	  if ((temp = fopen(tempfile, "w")) == NULL) {
  	    printf("Error: couldn't open tempfile '%s'.  Not removed\n",
***************
*** 124,133 ****
  
  	if ((repfile = fopen(autoreply_file, "r")) == NULL) {
  	  if (stat_only) {
! 	    printf("You're not currently autoreplying to mail.\n");
  	    exit(0);
  	  }
! 	  printf("No-one is autoreplying to their mail!\n");
  	  exit(0);
  	}
  
--- 126,135 ----
  
  	if ((repfile = fopen(autoreply_file, "r")) == NULL) {
  	  if (stat_only) {
! 	    printf("\nYou're not currently autoreplying to mail.\n");
  	    exit(0);
  	  }
! 	  printf("\nNo-one is autoreplying to their mail!\n");
  	  exit(0);
  	}
  
***************
*** 143,159 ****
  	  }
  	  else {
  	    if (stat_only) {
! 	      printf("You're currently autoreplying to mail with the file %s\n",		      filename); 
  	      exit(0);
  	    }
  	    found++;
  	  }
  
  	  fclose(temp);
  	fclose(repfile);
  
  	if (! found) {
! 	  printf("You're not currently autoreplying to mail%s\n",
  		  stat_only? "." : "!");
  	  if (! stat_only)
  	    unlink(tempfile);
--- 145,163 ----
  	  }
  	  else {
  	    if (stat_only) {
! 	      printf("\nYou're currently autoreplying to mail with the file %s\n",		      filename);
  	      exit(0);
  	    }
  	    found++;
  	  }
  
+ 	if (! stat_only)
  	  fclose(temp);
+ 
  	fclose(repfile);
  
  	if (! found) {
! 	  printf("\nYou're not currently autoreplying to mail%s\n",
  		  stat_only? "." : "!");
  	  if (! stat_only)
  	    unlink(tempfile);
***************
*** 191,200 ****
  	unlink(tempfile);
  
  	if (found > 1)
! 	  printf("Warning: your username appeared %d times!!   Removed all\n", 
  		  found);
  	else
! 	  printf("You've been removed from the autoreply table.\n");
  }
  
  add_user(filename)
--- 195,204 ----
  	unlink(tempfile);
  
  	if (found > 1)
! 	  printf("\nWarning: your username appeared %d times!!   Removed all\n",
  		  found);
  	else
! 	  printf("\nYou've been removed from the autoreply table.\n");
  }
  
  add_user(filename)
***************
*** 217,223 ****
  
  	fclose(repfile);
  
! 	printf("You've been added to the autoreply system.\n");
  }
  
  
--- 221,227 ----
  
  	fclose(repfile);
  
! 	printf("\nYou've been added to the autoreply system.\n");
  }
  
  
***************
*** 229,235 ****
  	    is to check to see if new mail has arrived....  **/
  
  	int ok = 1;
- 	extern int errno;	/* system error number! */
  	struct stat buffer;
  
  	if (stat(name, &buffer) != 0)
--- 233,238 ----
diff -cbr orig/utils/expand.c new/utils/expand.c
*** orig/utils/expand.c	Sat Oct 16 18:44:06 1993
--- new/utils/expand.c	Sun May 03 16:19:28 1992
***************
*** 28,36 ****
--- 28,39 ----
  **/
  
  #include <stdio.h>
+ #include <pwd.h>
  #include "defs.h"
  
  char *expand_define();
+ static struct passwd *pass;
+ static char *home;
  
  int
  expand(filename)
***************
*** 46,61 ****
  	**/
  
  	FILE *rcfile;
! 	char  buffer[SLEN], *expanded_dir, *home, *getenv(), *bufptr;
  	int   foundit = 0;
  
  	bufptr = (char *) buffer;		/* same address */
  
! 	if ((home = getenv("HOME")) == NULL) {
! 	  printf(
! 	     "Can't expand environment variable $HOME to find .elmrc file!\n");
! 	  return(NO);
  	}
  
  	sprintf(buffer, "%s/%s", home, elmrcfile);
  
--- 49,64 ----
  	**/
  
  	FILE *rcfile;
! 	char  buffer[SLEN], *expanded_dir, *bufptr;
  	int   foundit = 0;
  
  	bufptr = (char *) buffer;		/* same address */
  
! 	if((pass = getpwuid(getuid())) == NULL) {
! 	    printf("You have no password entry!\n");
! 	    exit(1);
  	}
+ 	home = pass->pw_dir;
  
  	sprintf(buffer, "%s/%s", home, elmrcfile);
  
***************
*** 122,128 ****
  	       *value;		      /* char pointer for munging */
  
  	if (*maildir == '~')
! 	  sprintf(buffer, "%s%s", getenv("HOME"), ++maildir);
  	else if (*maildir == '$') { 	/* shell variable */
  
  	  /** break it into a single word - the variable name **/
--- 125,131 ----
  	       *value;		      /* char pointer for munging */
  
  	if (*maildir == '~')
! 	  sprintf(buffer, "%s%s", home, ++maildir);
  	else if (*maildir == '$') { 	/* shell variable */
  
  	  /** break it into a single word - the variable name **/
diff -cbr orig/utils/fastmail.c new/utils/fastmail.c
*** orig/utils/fastmail.c	Sat Oct 16 18:44:06 1993
--- new/utils/fastmail.c	Sun Sep 26 16:12:56 1993
***************
*** 75,84 ****
  
  static char ident[] = { WHAT_STRING };
  
- #define  binrmail	"/bin/rmail"
- #define  temphome	"/tmp/fastmail."
- 
- 
  char *arpa_dayname[] = { "Sun", "Mon", "Tue", "Wed", "Thu",
  		  "Fri", "Sat", "" };
  
--- 75,80 ----
***************
*** 90,97 ****
--- 86,95 ----
  #if defined(BSD) && !defined(_POSIX_SOURCE)
    char *timezone();
  #else
+ #ifndef OS2
    extern char *tzname[];
  #endif
+ #endif
  
  main(argc, argv)
  int argc;
***************
*** 100,113 ****
  
  	extern char *optarg;
  	extern int optind;
! 	FILE *tempfile;
  	char hostname[NLEN], username[NLEN], from_string[SLEN], subject[SLEN];
  	char filename[SLEN], tempfilename[SLEN], command_buffer[256];
  	char replyto[SLEN], cc_list[SLEN], bcc_list[SLEN], to_list[SLEN];
! 	char from_addr[SLEN];
  	char *tmplogname;
  	int  c, sendmail_available, debug = 0;
  
  	from_string[0] = '\0';
  	subject[0] = '\0';
  	replyto[0] = '\0';
--- 98,113 ----
  
  	extern char *optarg;
  	extern int optind;
! 	FILE *tempfile, *mailpipe;
  	char hostname[NLEN], username[NLEN], from_string[SLEN], subject[SLEN];
  	char filename[SLEN], tempfilename[SLEN], command_buffer[256];
  	char replyto[SLEN], cc_list[SLEN], bcc_list[SLEN], to_list[SLEN];
! 	char from_addr[SLEN], buffer[SLEN], hostfromname[SLEN];
  	char *tmplogname;
  	int  c, sendmail_available, debug = 0;
  
+         initpaths();
+ 
  	from_string[0] = '\0';
  	subject[0] = '\0';
  	replyto[0] = '\0';
***************
*** 126,181 ****
  	    case 'r' : strcpy(replyto, optarg);		break;
  	    case 's' : strcpy(subject, optarg);		break;
  	    case '?' :
! 	      fprintf(stderr,"Usage: fastmail {args} filename address(es)\n");
! 	      fprintf(stderr, "   where {args} can be;\n");
! 	      fprintf(stderr,"\t-b bcc-list\n\t-c cc-list\n\t-d\n");
! 	      fprintf(stderr,"\t-f from-name\n\t-F from-addr\n");
! 	      fprintf(stderr, "\t-r reply-to\n\t-s subject\n\n");
! 	      exit(1);
   	  }
  	}
  
! 	if (optind >= argc) {
! 	  fprintf(stderr,"Usage: fastmail {args} filename address(es)\n");
! 	  fprintf(stderr, "   where {args} can be;\n");
! 	  fprintf(stderr,"\t-b bcc-list\n\t-c cc-list\n\t-d\n\t-f from-name\n");
! 	  fprintf(stderr,"\t-F from-addr\n");
! 	  fprintf(stderr, "\t-r reply-to\n\t-s subject\n\n");
! 	  exit(1);
! 	}
  
  	strcpy(filename, argv[optind++]);
  
! 	if (optind >= argc) {
! 	  fprintf(stderr,"Usage: fastmail {args} filename address(es)\n");
! 	  fprintf(stderr, "   where {args} can be;\n");
! 	  fprintf(stderr,"\t-b bcc-list\n\t-c cc-list\n\t-d\n\t-f from-name\n");
! 	  fprintf(stderr,"\t-F from-addr\n");
! 	  fprintf(stderr,"\t-r reply-to\n\t-s subject\n\n");
! 	  exit(1);
! 	}
  
  #ifdef HOSTCOMPILED
  	strncpy(hostname, HOSTNAME, sizeof(hostname));
  #else
  	gethostname(hostname, sizeof(hostname));
  #endif
  
! 	tmplogname = getlogin();
  	if (tmplogname != NULL)
  	  strcpy(username, tmplogname);
  	else
  	  username[0] = '\0';
  
  	if (strlen(username) == 0)
  	  cuserid(username);
  
  	if (access(filename, READ_ACCESS) == -1) {
  	  fprintf(stderr, "Error: can't find file %s!\n", filename);
  	  exit(1);
  	}
  
! 	sprintf(tempfilename, "%s%d", temphome, getpid());
  
  	if ((tempfile = fopen(tempfilename, "w")) == NULL) {
  	  fprintf(stderr, "Couldn't open temp file %s\n", tempfilename);
--- 126,172 ----
  	    case 'r' : strcpy(replyto, optarg);		break;
  	    case 's' : strcpy(subject, optarg);		break;
  	    case '?' :
! 	      usage();
   	  }
  	}
  
! 	if (optind >= argc)
! 	  usage();
  
  	strcpy(filename, argv[optind++]);
  
! 	if (optind >= argc)
!           usage();
  
  #ifdef HOSTCOMPILED
  	strncpy(hostname, HOSTNAME, sizeof(hostname));
  #else
  	gethostname(hostname, sizeof(hostname));
+ #endif
+ 
+ #ifdef OS2
+ 	getfromdomain(hostfromname, sizeof(hostfromname));
+ #else
+ 	strcpy(hostfromname, hostname);
  #endif
  
! 	tmplogname = getenv("LOGNAME");
  	if (tmplogname != NULL)
  	  strcpy(username, tmplogname);
  	else
  	  username[0] = '\0';
  
+ #ifndef OS2
  	if (strlen(username) == 0)
  	  cuserid(username);
+ #endif
  
  	if (access(filename, READ_ACCESS) == -1) {
  	  fprintf(stderr, "Error: can't find file %s!\n", filename);
  	  exit(1);
  	}
  
! 	sprintf(tempfilename, "%s%d.fm", tempdir, getpid());
  
  	if ((tempfile = fopen(tempfilename, "w")) == NULL) {
  	  fprintf(stderr, "Couldn't open temp file %s\n", tempfilename);
***************
*** 199,215 ****
  	**/
  	fprintf(tempfile, "Subject: %s\n", subject);
  
  	if (strlen(from_string) > 0)
- 	  if (strlen(from_addr) > 0)
  	  fprintf(tempfile, "From: %s (%s)\n", from_addr, from_string);
  	else
- 	      fprintf(tempfile, "From: %s!%s (%s)\n", hostname, username, 
- 		      from_string);
- 	else
- 	  if (strlen(from_addr) > 0)
  	  fprintf(tempfile, "From: %s\n", from_addr);
- 	  else
- 	    fprintf(tempfile, "From: %s!%s\n", hostname, username);
  
  	fprintf(tempfile, "Date: %s\n", get_arpa_date());
  
--- 192,204 ----
  	**/
  	fprintf(tempfile, "Subject: %s\n", subject);
  
+ 	if (strlen(from_addr) == 0)
+ 	  sprintf(from_addr, "%s@%s", username, hostfromname);
+ 
  	if (strlen(from_string) > 0)
  	  fprintf(tempfile, "From: %s (%s)\n", from_addr, from_string);
  	else
  	  fprintf(tempfile, "From: %s\n", from_addr);
  
  	fprintf(tempfile, "Date: %s\n", get_arpa_date());
  
***************
*** 241,257 ****
  		printf("Mailing to %s%s%s%s%s [via %s]\n", to_list,
  			(strlen(cc_list) > 0 ? " ":""), cc_list,
  			(strlen(bcc_list) > 0 ? " ":""), bcc_list,
! 			sendmail_available? "sendmail" : "rmail");
  
  	sprintf(command_buffer, "cat %s %s | %s %s %s %s",
  		tempfilename, filename,
  	        sendmail_available? sendmail : mailer,
  		to_list, cc_list, bcc_list);
  
  	if (debug)
  	  printf("%s\n", command_buffer);
  
  	c = system(command_buffer);
  
  	unlink(tempfilename);
  
--- 230,267 ----
  		printf("Mailing to %s%s%s%s%s [via %s]\n", to_list,
  			(strlen(cc_list) > 0 ? " ":""), cc_list,
  			(strlen(bcc_list) > 0 ? " ":""), bcc_list,
! 			sendmail_available? "sendmail" : mailer);
  
+ #ifdef OS2
+ 	if (strcmp(sendmail, mailer) == 0)
+ 	  sprintf(command_buffer, "%s -f %s %s %s %s", mailer, 
+ 		  from_addr, to_list, cc_list, bcc_list);
+ 	else
+ 	  sprintf(command_buffer, "%s -t", mailer);
+ #else
  	sprintf(command_buffer, "cat %s %s | %s %s %s %s",
  		tempfilename, filename,
  	        sendmail_available? sendmail : mailer,
  		to_list, cc_list, bcc_list);
+ #endif
  
  	if (debug)
  	  printf("%s\n", command_buffer);
  
+ #ifdef OS2
+         mailpipe = popen(command_buffer, "w");
+ 	tempfile = fopen(tempfilename, "r");
+         while ( fgets(buffer, sizeof(buffer), tempfile) != NULL )
+           fputs(buffer, mailpipe);
+         fclose(tempfile);
+ 	tempfile = fopen(filename, "r");
+         while ( fgets(buffer, sizeof(buffer), tempfile) != NULL )
+           fputs(buffer, mailpipe);
+         fclose(tempfile);
+         pclose(mailpipe);
+ #else
  	c = system(command_buffer);
+ #endif
  
  	unlink(tempfilename);
  
***************
*** 259,264 ****
--- 269,289 ----
  }
  
  
+ usage()
+ {
+   printf("\nUsage: fastmail {args} filename address(es)\n");
+   printf( "\nwhere {args} can be:\n\n");
+   printf("\t-b bcc-list       addresses to send blind-carbon copies to\n");
+   printf("\t-c cc-list        addresses to send carbon copies to\n");
+   printf("\t-d                debug\n");
+   printf("\t-f from-name      sender's full name\n");
+   printf("\t-F from-addr      sender's mail address\n");
+   printf("\t-r reply-to       reply-to mail address\n");
+   printf("\t-s subject        subject of the message\n");
+   exit(1);
+ }
+ 
+ 
  char *get_arpa_date()
  {
  	/** returns an ARPA standard date.  The format for the date
***************
*** 285,291 ****
  	struct  timezone time_zone;
  #  endif
  #else
! 	long time();
  #endif
  
  #ifdef BSD
--- 310,316 ----
  	struct  timezone time_zone;
  #  endif
  #else
! 	time_t time();
  #endif
  
  #ifdef BSD
diff -cbr orig/utils/from.c new/utils/from.c
*** orig/utils/from.c	Sat Oct 16 18:44:08 1993
--- new/utils/from.c	Sun Mar 22 11:38:32 1992
***************
*** 56,61 ****
--- 56,63 ----
  #endif
  	extern int optind;
  
+         initpaths();
+ 
  	while ((c = getopt(argc, argv, "nv")) != EOF)
  	  switch (c) {
  	    case (int)'n': number++;		break;
***************
*** 65,96 ****
  	                   exit(1);
  	  }
  
  	infile[0] = '\0';
  	if (optind == argc) {
  	/*
  	 *	determine mail file from environment variable if found,
  	 *	else use password entry
  	 */
- 	  if ((cp = getenv("MAIL")) == NULL) {
- 	    if((pass = getpwuid(getuid())) == NULL) {
- 	      printf("You have no password entry!");
- 	      exit(1);
- 	    }
- 	    sprintf(infile,"%s%s",mailhome, pass->pw_name);
- 	  }
- 	  else
- 	    strcpy(infile, cp);
  	  optind -= 1;	/* ensure one pass through loop */
  	}
  
- #ifdef MMDF
- 	if((pass = getpwuid(getuid())) == NULL) {
- 	  printf("You have no password entry!");
- 	  exit(1);
- 	}
- 	strcpy(username,pass->pw_name);
- #endif /* MMDF */
- 
  	multiple_files = (argc - optind > 1);
  
  	while (optind < argc) {
--- 67,91 ----
  	                   exit(1);
  	  }
  
+ 	if((pass = getpwuid(getuid())) == NULL) {
+ 	  printf("You have no password entry!");
+ 	  exit(1);
+ 	}
+ 	strcpy(username,pass->pw_name);
+ 
  	infile[0] = '\0';
  	if (optind == argc) {
  	/*
  	 *	determine mail file from environment variable if found,
  	 *	else use password entry
  	 */
  	  optind -= 1;	/* ensure one pass through loop */
+ 	  if ((cp = getenv("MAIL")) == NULL)
+ 	    strcpy(infile, argv[optind] = username);
+ 	  else
+ 	    strcpy(infile, argv[optind] = cp);
  	}
  
  	multiple_files = (argc - optind > 1);
  
  	while (optind < argc) {
***************
*** 111,119 ****
  	  }
  
  	  if ((mailfile = fopen(infile,"r")) == NULL) {
- 	    if (optind+1 == argc)
- 	      printf("No mail.\n");
- 	    else {
  	      if (infile[0] == '/')
  	        printf("Couldn't open folder \"%s\".\n", infile);
  	      else {
--- 106,111 ----
***************
*** 122,138 ****
  	          printf("Couldn't open folders \"%s\" or \"%s\".\n",
  			 argv[optind], infile);
  	        else {
! 		  if (read_headers()==0)
! 	            printf("No messages in that folder!\n");
  	          fclose(mailfile);
  		}
  	      }
- 	    }
  	  } else {
! 	    if (read_headers(optind+1 == argc)==0)
! 	      if (optind+1 == argc)
! 	        printf("No mail\n");
! 	      else
  	      printf("No messages in that folder!\n");
  	    fclose(mailfile);
  	  }
--- 114,126 ----
  	          printf("Couldn't open folders \"%s\" or \"%s\".\n",
  			 argv[optind], infile);
  	        else {
! 		  if (read_headers(1)==0)
! 	            printf("No mail.\n");
  	          fclose(mailfile);
  		}
  	      }
  	  } else {
! 	    if (read_headers(0)==0)
  	      printf("No messages in that folder!\n");
  	    fclose(mailfile);
  	  }
***************
*** 164,176 ****
  	  }
  
  #ifdef MMDF
!           if (strcmp(buffer, MSG_SEPERATOR) == 0) {
! 	    newheader = !newheader;
! 	    if (newheader) {
  	    subject[0] = '\0';
  	    in_header = 1;
  	  }
- 	  }
  #else
  	  if (first_word(buffer,"From ")
  	   && real_from(buffer, from_whom)) {
--- 152,163 ----
  	  }
  
  #ifdef MMDF
!           if (strcmp(buffer, MSG_SEPERATOR) == 0 || !newheader &&
!   	      first_word(buffer,"From ") && real_from(buffer, from_whom)) {
! 	    newheader = 1;
  	    subject[0] = '\0';
  	    in_header = 1;
  	  }
  #else
  	  if (first_word(buffer,"From ")
  	   && real_from(buffer, from_whom)) {
***************
*** 180,185 ****
--- 167,173 ----
  #endif /* MMDF */
  	  else if (in_header) {
  #ifdef MMDF
+             newheader = 0;
  	    if (first_word(buffer,"From "))
  	      real_from(buffer, from_whom);
  #endif /* MMDF */
diff -cbr orig/utils/listalias.c new/utils/listalias.c
*** orig/utils/listalias.c	Sat Oct 16 18:44:08 1993
--- new/utils/listalias.c	Sun Oct 04 14:21:38 1992
***************
*** 27,41 ****
  
  #include <stdio.h>
  #include <fcntl.h>
  
  #include "defs.h"
- #include "sysdefs.h"
  
  #ifdef BSD
    FILE *popen();
  #endif
  
  char *getenv();
  
  main(argc, argv)
  int argc;
--- 27,44 ----
  
  #include <stdio.h>
  #include <fcntl.h>
+ #include <pwd.h>
  
  #include "defs.h"
  
  #ifdef BSD
    FILE *popen();
  #endif
  
  char *getenv();
+ struct passwd *getpwuid();
+ struct passwd *pass;
+ char home[SLEN];		/* the users home directory  */
  
  main(argc, argv)
  int argc;
***************
*** 45,61 ****
  	struct alias_rec hash_record;
  	int hashfile, count = 0;
  	char buffer[SLEN], fd_hash[SLEN],
! 	     fd_data[SLEN], *home;
  
  	if (argc > 2) {
  	  printf("Usage: listalias <optional-regular-expression>\n");
  	  exit(1);
  	}
  
! 	home = getenv("HOME");
  
  	sprintf(fd_hash, "%s/%s", home, ALIAS_HASH);
  	sprintf(fd_data, "%s/%s", home, ALIAS_DATA);
  
  	if (argc > 1)
  	  sprintf(buffer, "egrep \"%s\" | sort", argv[1]);
--- 48,71 ----
  	struct alias_rec hash_record;
  	int hashfile, count = 0;
  	char buffer[SLEN], fd_hash[SLEN],
! 	     fd_data[SLEN];
! 
!         initpaths();
  
  	if (argc > 2) {
  	  printf("Usage: listalias <optional-regular-expression>\n");
  	  exit(1);
  	}
  
! 	if((pass = getpwuid(getuid())) == NULL) {
! 	  printf("You have no password entry!\n");
! 	  exit(1);
! 	}
! 	strcpy(home, pass->pw_dir);
  
  	sprintf(fd_hash, "%s/%s", home, ALIAS_HASH);
  	sprintf(fd_data, "%s/%s", home, ALIAS_DATA);
+         putc('\n', stdout);
  
  	if (argc > 1)
  	  sprintf(buffer, "egrep \"%s\" | sort", argv[1]);
***************
*** 81,87 ****
  
  	    while (read(hashfile, &hash_record, sizeof (hash_record)) != 0) {
  	      if (strlen(hash_record.name) > 0) {
! 	        fseek(datafile, ntohl(hash_record.byte), 0L);
  	        fgets(buffer, SLEN, datafile);
  	        fprintf(fd_pipe, "%-15s  %s", hash_record.name, buffer);
  	      }
--- 91,97 ----
  
  	    while (read(hashfile, &hash_record, sizeof (hash_record)) != 0) {
  	      if (strlen(hash_record.name) > 0) {
! 	        fseek(datafile, ntohl(hash_record.byte), 0);
  	        fgets(buffer, SLEN, datafile);
  	        fprintf(fd_pipe, "%-15s  %s", hash_record.name, buffer);
  	      }
diff -cbr orig/utils/Makefile new/utils/Makefile
*** orig/utils/Makefile	Sat Oct 16 18:44:08 1993
--- new/utils/Makefile	Fri Apr 22 20:06:18 1994
***************
*** 2,19 ****
  #  Makefile for the Elm system utilities for OS/2
  #
  
! gcc:
  	$(MAKE) all CC="gcc -O -Zomf -Zmtd" O=".obj" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm32.def"
  
! gccdebug:
  	$(MAKE) all CC="gcc -g" O=".o" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm32.def"
! 
! msc:
! 	$(MAKE) all CC="cl -nologo -AL -Gs -Ocegt" O=".obj" \
! 	CFLAGS="-W1 -Zep1 -Gt16 -D__STDC__ -G2 -J" \
! 	LFLAGS="-Lp" LIBS="..\os2\elm16.def -link /noe /packc /packd"
  
  # Variables
  
--- 2,14 ----
  #  Makefile for the Elm system utilities for OS/2
  #
  
! release:
  	$(MAKE) all CC="gcc -O -Zomf -Zmtd" O=".obj" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm.def"
  
! debug:
  	$(MAKE) all CC="gcc -g" O=".o" \
! 	CFLAGS="" LFLAGS="" LIBS="../os2/elm.def"
  
  # Variables
  
***************
*** 26,49 ****
  # Lists
  
  BINARY_LIST	= answer.exe arepdaemon.exe autoreply.exe fastmail.exe \
! 	from.exe listalias.exe newalias.exe newmail.exe readmsg.exe
  
! OS2_OBJ		= getopt$O os2util$O
  UTIL_OBJ	= answer$O arepdaem$O autoreply$O expand$O \
  	fastmail$O from$O listalias$O newalias$O newmail$O readmsg$O \
  	opt_utils$O string2$O validname$O errno$O
  
  # Lists of source and object files for each C program
  
! ANSWER_OBJ	= answer$O opt_utils$O string2$O os2util$O
! AREPDAEMON_OBJ	= arepdaem$O opt_utils$O errno$O os2util$O
! AUTOREPLY_OBJ	= autoreply$O opt_utils$O os2util$O
! FASTMAIL_OBJ	= fastmail$O opt_utils$O getopt$O os2util$O
! FRM_OBJ		= from$O expand$O opt_utils$O string2$O getopt$O os2util$O
! LISTALIAS_OBJ	= listalias$O os2util$O
! NEWALIAS_OBJ	= newalias$O validname$O opt_utils$O string2$O os2util$O
! NEWMAIL_OBJ	= newmail$O expand$O opt_utils$O string2$O getopt$O os2util$O
! READMSG_OBJ	= readmsg$O expand$O opt_utils$O string2$O getopt$O os2util$O
  
  # Standard targets
  
--- 21,45 ----
  # Lists
  
  BINARY_LIST	= answer.exe arepdaemon.exe autoreply.exe fastmail.exe \
! 	from.exe listalias.exe newalias.exe newmail.exe readmsg.exe sndmail.exe
  
! OS2_OBJ		= getopt$O os2util$O movemail$O
  UTIL_OBJ	= answer$O arepdaem$O autoreply$O expand$O \
  	fastmail$O from$O listalias$O newalias$O newmail$O readmsg$O \
  	opt_utils$O string2$O validname$O errno$O
  
  # Lists of source and object files for each C program
  
! ANSWER_OBJ	= answer$O opt_utils$O string2$O $(OS2_OBJ)
! AREPDAEMON_OBJ	= arepdaem$O opt_utils$O errno$O $(OS2_OBJ)
! AUTOREPLY_OBJ	= autoreply$O opt_utils$O $(OS2_OBJ)
! FASTMAIL_OBJ	= fastmail$O opt_utils$O $(OS2_OBJ)
! FRM_OBJ		= from$O expand$O opt_utils$O string2$O $(OS2_OBJ)
! LISTALIAS_OBJ	= listalias$O $(OS2_OBJ)
! NEWALIAS_OBJ	= newalias$O validname$O opt_utils$O string2$O $(OS2_OBJ)
! NEWMAIL_OBJ	= newmail$O expand$O opt_utils$O string2$O $(OS2_OBJ)
! READMSG_OBJ	= readmsg$O expand$O opt_utils$O string2$O $(OS2_OBJ)
! SNDMAIL_OBJ     = sndmail$O
  
  # Standard targets
  
***************
*** 95,100 ****
--- 91,99 ----
  readmsg.exe:	$(READMSG_OBJ)
  		$(CC) $(LFLAGS) -o $@ $(READMSG_OBJ) $(LIBS)
  
+ sndmail.exe:	$(SNDMAIL_OBJ)
+ 		$(CC) $(LFLAGS) -o $@ $(SNDMAIL_OBJ) $(LIBS)
+ 
  # Dependencies of header files upon other header files they include
  
  $(INCLDIR)/defs.h:	$(INCLDIR)/../config.h $(INCLDIR)/sysdefs.h
***************
*** 132,134 ****
--- 131,135 ----
  		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/getopt.c
  os2util$O:	$(OS2DIR)/os2util.c
  		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/os2util.c
+ movemail$O:	$(OS2DIR)/movemail.c
+ 		$(CC) $(CFLAGS) $(DEFINES) -c $(OS2DIR)/movemail.c
diff -cbr orig/utils/newalias.c new/utils/newalias.c
*** orig/utils/newalias.c	Sat Oct 16 18:44:08 1993
--- new/utils/newalias.c	Sun Mar 29 00:07:34 1992
***************
*** 57,64 ****
  
  #include <stdio.h>
  #include "defs.h"
- #include "sysdefs.h"		/* ELM system definitions */
  #include <ctype.h>
  
  #ifdef BSD
  #  include <sys/file.h>
--- 57,64 ----
  
  #include <stdio.h>
  #include "defs.h"
  #include <ctype.h>
+ #include <pwd.h>
  
  #ifdef BSD
  #  include <sys/file.h>
***************
*** 85,90 ****
--- 85,93 ----
  int  is_system=0;		/* system file updating?     */
  int  count=0;			/* how many aliases so far?  */
  long offset = 0L;		/* data file line offset!    */
+ 
+ struct passwd *getpwuid();
+ struct passwd *pass;
  char home[SLEN];		/* the users home directory  */
  
  main(argc, argv)
***************
*** 96,126 ****
  	char buffer[LONG_STRING];
  	int  a, hash, count = 0, owner;
  
  	for (a = 1; a < argc; ++a) {
  	  if (strcmp(argv[a], "-g") == 0)
  	    is_system = 1;
  	  else {
! 	    printf("Usage: %s [-g]\n", argv[0]);
  	    exit(1);
  	  }
  	}
  
  	if (is_system) {   /* update system aliases */
! 	  printf("Updating the system alias file...\n");
  
- 	  strcpy(inputname, system_text_file);
- 	  strcpy(hashname,  system_hash_file);
- 	  strcpy(dataname,  system_data_file);
  	  init_table(shash_table, MAX_SALIASES);
  	}
  	else
! 	  printf("Updating your personal alias file...\n");
  
  	if (! is_system) {
! 	  if (strcpy(home, getenv("HOME")) == NULL) {
! 	    printf("I'm confused - no HOME variable in environment!\n");
  	    exit(1);
  	  }
  
  	  sprintf(inputname, "%s/%s", home, ALIAS_TEXT);
  	  sprintf(hashname, "%s/%s", home, ALIAS_HASH);
--- 99,133 ----
  	char buffer[LONG_STRING];
  	int  a, hash, count = 0, owner;
  
+         initpaths();
+ 
  	for (a = 1; a < argc; ++a) {
  	  if (strcmp(argv[a], "-g") == 0)
  	    is_system = 1;
  	  else {
! 	    printf("\nUsage: %s [-g]\n", argv[0]);
  	    exit(1);
  	  }
  	}
  
  	if (is_system) {   /* update system aliases */
! 	  printf("\nUpdating the system alias file...\n");
! 
! 	  sprintf(inputname, "%s/%s", elmhome, system_text_file);
! 	  sprintf(hashname, "%s/%s", elmhome, system_hash_file);
! 	  sprintf(dataname, "%s/%s", elmhome, system_data_file);
  
  	  init_table(shash_table, MAX_SALIASES);
  	}
  	else
! 	  printf("\nUpdating your personal alias file...\n");
  
  	if (! is_system) {
! 	  if((pass = getpwuid(getuid())) == NULL) {
! 	    printf("You have no password entry!\n");
  	    exit(1);
  	  }
+ 	  strcpy(home, pass->pw_dir);
  
  	  sprintf(inputname, "%s/%s", home, ALIAS_TEXT);
  	  sprintf(hashname, "%s/%s", home, ALIAS_HASH);
***************
*** 144,155 ****
  	  }
  	}
  
! 	if ((hash = open(hashname, O_WRONLY | O_TRUNC | O_CREAT, 0644)) == -1) {
  	  printf("Couldn't open %s for output!\n", hashname);
  	  exit(1);
  	}
  
! 	if ((data = fopen(dataname,"w")) == NULL) {
  	  printf("Couldn't open %s for output!\n", dataname);
  	  exit(1);
  	}
--- 151,162 ----
  	  }
  	}
  
! 	if ((hash = open(hashname, O_WRONLY  | O_BINARY | O_TRUNC | O_CREAT, 0644)) == -1) {
  	  printf("Couldn't open %s for output!\n", hashname);
  	  exit(1);
  	}
  
! 	if ((data = fopen(dataname,"wb")) == NULL) {
  	  printf("Couldn't open %s for output!\n", dataname);
  	  exit(1);
  	}
diff -cbr orig/utils/newmail.c new/utils/newmail.c
*** orig/utils/newmail.c	Sat Oct 16 18:44:10 1993
--- new/utils/newmail.c	Fri Apr 22 18:36:02 1994
***************
*** 83,88 ****
--- 83,89 ----
  #include <errno.h>
  #include <sys/types.h>
  #include <sys/stat.h>
+ #include <pwd.h>
  
  #include "defs.h"
  
***************
*** 138,143 ****
--- 139,146 ----
  	long lastsize,
  	     newsize;			/* file size for comparison..      */
  
+         initpaths();
+ 
  #ifdef HOSTCOMPILED
  	strncpy(hostname, HOSTNAME, sizeof(hostname));
  #else
***************
*** 166,172 ****
  	if (ptr == argv[0] && i == 0 && argv[0][0] == 'w')
  	  in_window = 1;
  
! 	while ((c = getopt(argc, argv, "di:w")) != EOF) {
  	  switch (c) {
  	    case 'd' : debug++;					break;
  	    case 'i' : interval_time = atoi(optarg);		break;
--- 169,175 ----
  	if (ptr == argv[0] && i == 0 && argv[0][0] == 'w')
  	  in_window = 1;
  
! 	while ((c = getopt(argc, argv, "di:wh?")) != EOF) {
  	  switch (c) {
  	    case 'd' : debug++;					break;
  	    case 'i' : interval_time = atoi(optarg);		break;
***************
*** 199,211 ****
--- 202,217 ----
  	  (void) signal(SIGQUIT, SIG_IGN);
  	}
  #endif
+ #ifdef SIGHUP
  	(void) signal(SIGHUP, SIG_DFL);
+ #endif
  
  	if (in_window && ! debug)
  	  printf("Incoming mail:\n");
  
  	while (1) {
  
+ #ifndef OS2
  #ifdef PIDCHECK
  	if ( kill(parent_pid,0))
  		exit(0);
***************
*** 215,226 ****
--- 221,235 ----
  	    exit();
  #endif /* AUTO_BACKGROUND */
  #endif /* PIDCHECK */
+ #endif
  
  	  if (! isatty(1))	/* we're not sending output to a tty any more */
  	     exit();
  
  	  if (debug) printf("\n----\n");
  
+ 	  /* move_incoming_mail(); */
+ 
  	  for (i = 0; i < total_folders; i++) {
  
  	    if (debug)
***************
*** 303,309 ****
  	while (fgets(buffer, SLEN, folders[current_folder].fd) != NULL) {
  #ifdef MMDF
            if (strcmp(buffer, MSG_SEPERATOR) == 0) {
!             newheader = !newheader;
              if (newheader) {
  #else
  	  if (first_word(buffer,"From ")) {
--- 312,318 ----
  	while (fgets(buffer, SLEN, folders[current_folder].fd) != NULL) {
  #ifdef MMDF
            if (strcmp(buffer, MSG_SEPERATOR) == 0) {
!             newheader = 1;
              if (newheader) {
  #else
  	  if (first_word(buffer,"From ")) {
***************
*** 314,320 ****
  	      in_header = 1;
  	      subject[0] ='\0';
  	      if (in_window)
! 	        putchar((char) 007);		/* BEEP!*/
  	      else
  	        printf("\n\r");	/* blank lines surrounding message */
  
--- 323,329 ----
  	      in_header = 1;
  	      subject[0] ='\0';
  	      if (in_window)
! 	        putc((char) 007, stdout);		/* BEEP!*/
  	      else
  	        printf("\n\r");	/* blank lines surrounding message */
  
***************
*** 575,581 ****
  #ifndef INTERNET
  	/* Remove bogus "@host.domain" string. */
  
! 	sprintf(buffer, "@%s%s", hostname, hostdomain);
  
  	if (chloc(from, '!') != -1 && in_string(from, buffer))
  	  from[strlen(from) - strlen(buffer)] = '\0';
--- 575,581 ----
  #ifndef INTERNET
  	/* Remove bogus "@host.domain" string. */
  
! 	sprintf(buffer, "@%s", hostname); /* hostname should contain FQDN! */
  
  	if (chloc(from, '!') != -1 && in_string(from, buffer))
  	  from[strlen(from) - strlen(buffer)] = '\0';
***************
*** 703,709 ****
  	    is to check to see if new mail has arrived....  **/
  
  	int ok = 1;
- 	extern int errno;	/* system error number! */
  	struct stat buffer;
  
  	if (stat(name, &buffer) != 0)
--- 712,717 ----
***************
*** 722,736 ****
  	/** Getting the username on some systems is a real pain, so...
  	   This routine is guaranteed to return a usable username **/
  
! 	char *return_value, *getlogin(), *cuserid();
! 
! 	if ((return_value = getlogin()) == NULL)
! 	  if ((return_value = cuserid(NULL)) == NULL) {
! 	    printf("Newmail: I can't get username!\n");
! 	    exit(1);
! 	  }
  
! 	return( (char *) return_value);
  }
  
  usage(name)
--- 730,740 ----
  	/** Getting the username on some systems is a real pain, so...
  	   This routine is guaranteed to return a usable username **/
  
!   struct passwd *password_entry;
!   struct passwd *getpwuid();
  
!   if (( password_entry = getpwuid(getuid())) != NULL)
!     return(password_entry->pw_name);
  }
  
  usage(name)
diff -cbr orig/utils/readmsg.c new/utils/readmsg.c
*** orig/utils/readmsg.c	Sat Oct 16 18:44:10 1993
--- new/utils/readmsg.c	Sat Mar 28 23:30:58 1992
***************
*** 44,49 ****
--- 44,50 ----
  
  #include <stdio.h>
  #include <ctype.h>
+ #include <pwd.h>
  
  #include "defs.h"
  
***************
*** 69,74 ****
--- 70,78 ----
  int numcmp();				/* strcmp, but for numbers          */
  char *words();				/* function defined below...        */
  
+ struct passwd *getpwuid();
+ struct passwd *pass;
+ char home[SLEN];		/* the users home directory  */
  
  extern char *optarg;		/* for parsing the ... 		    */
  extern int   optind;			/*  .. starting arguments           */
***************
*** 84,90 ****
  	     infile[SLEN],			/* input filename	    */
  	     buffer[SLEN], 			/* file reading buffer      */
  	     string[SLEN],			/* string match buffer      */
! 	     *cp;
  
  	int current_in_queue = 0, 		/* these are used for...     */
  	    current = 0,			/* ...going through msgs     */
--- 88,95 ----
  	     infile[SLEN],			/* input filename	    */
  	     buffer[SLEN], 			/* file reading buffer      */
  	     string[SLEN],			/* string match buffer      */
! 	     *cp,
!              *prog = argv[0];
  
  	int current_in_queue = 0, 		/* these are used for...     */
  	    current = 0,			/* ...going through msgs     */
***************
*** 102,107 ****
--- 107,114 ----
  	    string[0] = '\0';			/* init match string to empty */
  	    infile[0] = '\0';			/* init mail file to empty    */
  
+         initpaths();
+ 
  	/**** start of the actual program ****/
  
  	while ((num = getopt(argc, argv, "nhf:p")) != EOF) {
***************
*** 115,123 ****
  			          argv[0], infile);
  		       break;
  	    case 'p' : page_breaks++;			break;
! 	    case '?' : printf(
! 			"Usage: %s [-n|-h] [-f filename] [-p] <message list>\n",
! 			 argv[0]);
  	  	       exit(1);
  	  }
  	}
--- 122,128 ----
  			          argv[0], infile);
  		       break;
  	    case 'p' : page_breaks++;			break;
! 	    case '?' : usage(prog);
  	  	       exit(1);
  	  }
  	}
***************
*** 135,148 ****
  	/** now let's figure out the parameters to the program... **/
  
  	if (argc == 1) {	/* no arguments... called from 'Elm'? */
! 	  sprintf(filename, "%s/%s", getenv("HOME"), readmsg_file);
  	  if ((file = fopen(filename, "r")) != NULL) {
  	    fscanf(file, "%d", &(read_message[messages++]));
  	    fclose(file);
  	  }
  	  else {	/* no arguments AND no .readmsg file!! */
! 	    fprintf(stderr,
! 	        "Usage: readmsg [-n|-h] [-f filename] [-p] <message list>\n");
  	    exit(1);
  	  }
  	}
--- 140,157 ----
  	/** now let's figure out the parameters to the program... **/
  
  	if (argc == 1) {	/* no arguments... called from 'Elm'? */
! 	  if((pass = getpwuid(getuid())) == NULL) {
! 	    printf("You have no password entry!\n");
! 	    exit(1);
! 	  }
! 	  strcpy(home, pass->pw_dir);
! 	  sprintf(filename, "%s/%s", home, readmsg_file);
  	  if ((file = fopen(filename, "r")) != NULL) {
  	    fscanf(file, "%d", &(read_message[messages++]));
  	    fclose(file);
  	  }
  	  else {	/* no arguments AND no .readmsg file!! */
!             usage(prog);
  	    exit(1);
  	  }
  	}
***************
*** 233,241 ****
  
  	while (fgets(buffer, SLEN, file) != NULL) {
  #ifdef MMDF
! 	  if (strcmp(buffer, MSG_SEPERATOR) == 0)
! 	    newheader = !newheader;
! 	  if (newheader && buffer[0] == '\001') {
  #else
  	  if (real_from(buffer)) {
  #endif /* MMDF */
--- 242,253 ----
  
  	while (fgets(buffer, SLEN, file) != NULL) {
  #ifdef MMDF
! 	  if (strcmp(buffer, MSG_SEPERATOR) == 0 ||
!               !newheader && real_from(buffer))
!             newheader = 1; /* !newheader; */
!           else
!             newheader = 0;
! 	  if (newheader) {
  #else
  	  if (real_from(buffer)) {
  #endif /* MMDF */
***************
*** 248,253 ****
--- 260,266 ----
  	    current++;
  	    not_in_header = 0;	/* we're in the header! */
  	  }
+ 
  	  if (current == read_message[current_in_queue] || list_all_messages)
  #ifdef MMDF
  	    if ((include_headers==ALL || not_in_header)
***************
*** 268,273 ****
--- 281,296 ----
  	exit(0);
  }
  
+ usage(prog)
+ char *prog;
+ {
+   printf("\nUsage: %s [-n|-h] [-f filename] [-p] <message list>\n", prog);
+   printf("\n  -n   don't print any headers"
+          "\n  -h   print all headers"
+          "\n  -p   printf form feeds between messages\n"
+          "\n  -f filename    use this instead of default mailbox\n");
+ }
+ 
  int
  count_messages(file)
  FILE *file;
***************
*** 282,293 ****
  
  	while (fgets(buffer, SLEN, file) != NULL)
  #ifdef MMDF
! 	  if ((strcmp(buffer, MSG_SEPERATOR) == 0)
! 	    && (++newheader % 2))
  #else
! 	  if (real_from(buffer))
  #endif /* MMDF */
  	    count++;
  
  	rewind( file );
  	return( count );
--- 305,322 ----
  
  	while (fgets(buffer, SLEN, file) != NULL)
  #ifdef MMDF
! 	  if (strcmp(buffer, MSG_SEPERATOR) == 0
!               || !newheader && real_from(buffer)) {
! 	    newheader = 1;
  #else
! 	  if (real_from(buffer)) |
  #endif /* MMDF */
  	    count++;
+           }
+ #ifdef MMDF
+           else
+ 	    newheader = 0;
+ #endif /* MMDF */
  
  	rewind( file );
  	return( count );
***************
*** 309,320 ****
  
  	while (fgets(buffer, SLEN, mailfile) != NULL) {
  #ifdef MMDF
! 	  if ((strcmp(buffer, MSG_SEPERATOR) == 0)
! 	    && (++newheader % 2))
  #else
! 	  if (real_from(buffer))
  #endif /* MMDF */
  	    message_count++;
  
  	  if (in_string(buffer, string)) {
  	    read_message[messages++] = message_count;
--- 338,355 ----
  
  	while (fgets(buffer, SLEN, mailfile) != NULL) {
  #ifdef MMDF
! 	  if (strcmp(buffer, MSG_SEPERATOR) == 0
!               || !newheader && real_from(buffer)) {
! 	    newheader = 1;
  #else
! 	  if (real_from(buffer)) {
  #endif /* MMDF */
  	    message_count++;
+           }
+ #ifdef MMDF
+           else
+ 	    newheader = 0;
+ #endif /* MMDF */
  
  	  if (in_string(buffer, string)) {
  	    read_message[messages++] = message_count;
***************
*** 375,381 ****
  
  	if (messages_listed++)
  	  if (page_break)
! 	    putchar(FORMFEED);	
  	  else
  	    printf(
  "\n--------------------------------------------------------------------\n\n\n");
--- 410,416 ----
  
  	if (messages_listed++)
  	  if (page_break)
! 	    putc(FORMFEED, stdout);
  	  else
  	    printf(
  "\n--------------------------------------------------------------------\n\n\n");
***************
*** 386,392 ****
  	if (strlen(date)    > 0) { printf("%s", date);    displayed_line++;}
  
  	if (displayed_line)
! 	   putchar('\n');
  }
  
  char *words(word, num_words, buffer)
--- 421,427 ----
  	if (strlen(date)    > 0) { printf("%s", date);    displayed_line++;}
  
  	if (displayed_line)
! 	   putc('\n', stdout);
  }
  
  char *words(word, num_words, buffer)
